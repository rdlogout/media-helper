{"version":3,"sources":["../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/_internal/utils.mjs","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs","../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.7_unenv@2.0.0-rc.21_workerd@1.20251105.0/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/console.mjs","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/mock/noop.mjs","../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.7_unenv@2.0.0-rc.21_workerd@1.20251105.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs","../node_modules/.pnpm/alchemy@0.77.0_workerd@1.20251105.0_wrangler@4.46.0_@cloudflare+workers-types@4.20251109.0_/node_modules/alchemy/lib/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/process/process.mjs","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs","../node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs","../node_modules/.pnpm/@cloudflare+unenv-preset@2.7.7_unenv@2.0.0-rc.21_workerd@1.20251105.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs","../node_modules/.pnpm/alchemy@0.77.0_workerd@1.20251105.0_wrangler@4.46.0_@cloudflare+workers-types@4.20251109.0_/node_modules/alchemy/lib/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process","service.ts","../node_modules/.pnpm/@cf-wasm+internals@0.1.0/node_modules/@cf-wasm/internals/src/polyfills/image-data.ts","../node_modules/.pnpm/@cf-wasm+photon@0.2.1/node_modules/@cf-wasm/photon/src/lib/photon_rs.js","../node_modules/.pnpm/@cf-wasm+photon@0.2.1/node_modules/@cf-wasm/photon/src/photon.ts","../node_modules/.pnpm/@cf-wasm+photon@0.2.1/node_modules/@cf-wasm/photon/src/workerd.ts"],"sourceRoot":".alchemy/out/image-proxy","sourcesContent":["/* @__NO_SIDE_EFFECTS__ */\nexport function rawHeaders(headers) {\n\tconst rawHeaders = [];\n\tfor (const key in headers) {\n\t\tif (Array.isArray(headers[key])) {\n\t\t\tfor (const h of headers[key]) {\n\t\t\t\trawHeaders.push(key, h);\n\t\t\t}\n\t\t} else {\n\t\t\trawHeaders.push(key, headers[key]);\n\t\t}\n\t}\n\treturn rawHeaders;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function mergeFns(...functions) {\n\treturn function(...args) {\n\t\tfor (const fn of functions) {\n\t\t\tfn(...args);\n\t\t}\n\t};\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function createNotImplementedError(name) {\n\treturn new Error(`[unenv] ${name} is not implemented yet!`);\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplemented(name) {\n\tconst fn = () => {\n\t\tthrow createNotImplementedError(name);\n\t};\n\treturn Object.assign(fn, { __unenv__: true });\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedAsync(name) {\n\tconst fn = notImplemented(name);\n\tfn.__promisify__ = () => notImplemented(name + \".__promisify__\");\n\tfn.native = fn;\n\treturn fn;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedClass(name) {\n\treturn class {\n\t\t__unenv__ = true;\n\t\tconstructor() {\n\t\t\tthrow new Error(`[unenv] ${name} is not implemented yet!`);\n\t\t}\n\t};\n}\n","import { createNotImplementedError } from \"../../../_internal/utils.mjs\";\nconst _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();\nconst _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;\nconst nodeTiming = {\n\tname: \"node\",\n\tentryType: \"node\",\n\tstartTime: 0,\n\tduration: 0,\n\tnodeStart: 0,\n\tv8Start: 0,\n\tbootstrapComplete: 0,\n\tenvironment: 0,\n\tloopStart: 0,\n\tloopExit: 0,\n\tidleTime: 0,\n\tuvMetricsInfo: {\n\t\tloopCount: 0,\n\t\tevents: 0,\n\t\teventsWaiting: 0\n\t},\n\tdetail: undefined,\n\ttoJSON() {\n\t\treturn this;\n\t}\n};\n// PerformanceEntry\nexport class PerformanceEntry {\n\t__unenv__ = true;\n\tdetail;\n\tentryType = \"event\";\n\tname;\n\tstartTime;\n\tconstructor(name, options) {\n\t\tthis.name = name;\n\t\tthis.startTime = options?.startTime || _performanceNow();\n\t\tthis.detail = options?.detail;\n\t}\n\tget duration() {\n\t\treturn _performanceNow() - this.startTime;\n\t}\n\ttoJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tentryType: this.entryType,\n\t\t\tstartTime: this.startTime,\n\t\t\tduration: this.duration,\n\t\t\tdetail: this.detail\n\t\t};\n\t}\n}\n// PerformanceMark\nexport const PerformanceMark = class PerformanceMark extends PerformanceEntry {\n\tentryType = \"mark\";\n\tconstructor() {\n\t\t// @ts-ignore\n\t\tsuper(...arguments);\n\t}\n\tget duration() {\n\t\treturn 0;\n\t}\n};\n// PerformanceMark\nexport class PerformanceMeasure extends PerformanceEntry {\n\tentryType = \"measure\";\n}\n// PerformanceResourceTiming\nexport class PerformanceResourceTiming extends PerformanceEntry {\n\tentryType = \"resource\";\n\tserverTiming = [];\n\tconnectEnd = 0;\n\tconnectStart = 0;\n\tdecodedBodySize = 0;\n\tdomainLookupEnd = 0;\n\tdomainLookupStart = 0;\n\tencodedBodySize = 0;\n\tfetchStart = 0;\n\tinitiatorType = \"\";\n\tname = \"\";\n\tnextHopProtocol = \"\";\n\tredirectEnd = 0;\n\tredirectStart = 0;\n\trequestStart = 0;\n\tresponseEnd = 0;\n\tresponseStart = 0;\n\tsecureConnectionStart = 0;\n\tstartTime = 0;\n\ttransferSize = 0;\n\tworkerStart = 0;\n\tresponseStatus = 0;\n}\n// PerformanceObserverEntryList\nexport class PerformanceObserverEntryList {\n\t__unenv__ = true;\n\tgetEntries() {\n\t\treturn [];\n\t}\n\tgetEntriesByName(_name, _type) {\n\t\treturn [];\n\t}\n\tgetEntriesByType(type) {\n\t\treturn [];\n\t}\n}\n// Performance\nexport class Performance {\n\t__unenv__ = true;\n\ttimeOrigin = _timeOrigin;\n\teventCounts = new Map();\n\t_entries = [];\n\t_resourceTimingBufferSize = 0;\n\tnavigation = undefined;\n\ttiming = undefined;\n\ttimerify(_fn, _options) {\n\t\tthrow createNotImplementedError(\"Performance.timerify\");\n\t}\n\tget nodeTiming() {\n\t\treturn nodeTiming;\n\t}\n\teventLoopUtilization() {\n\t\treturn {};\n\t}\n\tmarkResourceTiming() {\n\t\t// TODO: create a new PerformanceResourceTiming entry\n\t\t// so that performance.getEntries, getEntriesByName, and getEntriesByType return it\n\t\t// see: https://nodejs.org/api/perf_hooks.html#performancemarkresourcetimingtiminginfo-requestedurl-initiatortype-global-cachemode-bodyinfo-responsestatus-deliverytype\n\t\treturn new PerformanceResourceTiming(\"\");\n\t}\n\tonresourcetimingbufferfull = null;\n\tnow() {\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Performance/now\n\t\tif (this.timeOrigin === _timeOrigin) {\n\t\t\treturn _performanceNow();\n\t\t}\n\t\treturn Date.now() - this.timeOrigin;\n\t}\n\tclearMarks(markName) {\n\t\tthis._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== \"mark\");\n\t}\n\tclearMeasures(measureName) {\n\t\tthis._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== \"measure\");\n\t}\n\tclearResourceTimings() {\n\t\tthis._entries = this._entries.filter((e) => e.entryType !== \"resource\" || e.entryType !== \"navigation\");\n\t}\n\tgetEntries() {\n\t\treturn this._entries;\n\t}\n\tgetEntriesByName(name, type) {\n\t\treturn this._entries.filter((e) => e.name === name && (!type || e.entryType === type));\n\t}\n\tgetEntriesByType(type) {\n\t\treturn this._entries.filter((e) => e.entryType === type);\n\t}\n\tmark(name, options) {\n\t\t// @ts-expect-error constructor is not protected\n\t\tconst entry = new PerformanceMark(name, options);\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tmeasure(measureName, startOrMeasureOptions, endMark) {\n\t\tlet start;\n\t\tlet end;\n\t\tif (typeof startOrMeasureOptions === \"string\") {\n\t\t\tstart = this.getEntriesByName(startOrMeasureOptions, \"mark\")[0]?.startTime;\n\t\t\tend = this.getEntriesByName(endMark, \"mark\")[0]?.startTime;\n\t\t} else {\n\t\t\tstart = Number.parseFloat(startOrMeasureOptions?.start) || this.now();\n\t\t\tend = Number.parseFloat(startOrMeasureOptions?.end) || this.now();\n\t\t}\n\t\tconst entry = new PerformanceMeasure(measureName, {\n\t\t\tstartTime: start,\n\t\t\tdetail: {\n\t\t\t\tstart,\n\t\t\t\tend\n\t\t\t}\n\t\t});\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tsetResourceTimingBufferSize(maxSize) {\n\t\tthis._resourceTimingBufferSize = maxSize;\n\t}\n\taddEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.addEventListener\");\n\t}\n\tremoveEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.removeEventListener\");\n\t}\n\tdispatchEvent(event) {\n\t\tthrow createNotImplementedError(\"Performance.dispatchEvent\");\n\t}\n\ttoJSON() {\n\t\treturn this;\n\t}\n}\n// PerformanceObserver\nexport class PerformanceObserver {\n\t__unenv__ = true;\n\tstatic supportedEntryTypes = [];\n\t_callback = null;\n\tconstructor(callback) {\n\t\tthis._callback = callback;\n\t}\n\ttakeRecords() {\n\t\treturn [];\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.disconnect\");\n\t}\n\tobserve(options) {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.observe\");\n\t}\n\tbind(fn) {\n\t\treturn fn;\n\t}\n\trunInAsyncScope(fn, thisArg, ...args) {\n\t\treturn fn.call(thisArg, ...args);\n\t}\n\tasyncId() {\n\t\treturn 0;\n\t}\n\ttriggerAsyncId() {\n\t\treturn 0;\n\t}\n\temitDestroy() {\n\t\treturn this;\n\t}\n}\n// workerd implements a subset of globalThis.performance (as of last check, only timeOrigin set to 0 + now() implemented)\n// We already use performance.now() from globalThis.performance, if provided (see top of this file)\n// If we detect this condition, we can just use polyfill instead.\nexport const performance = globalThis.performance && \"addEventListener\" in globalThis.performance ? globalThis.performance : new Performance();\n","import {\n  performance,\n  Performance,\n  PerformanceEntry,\n  PerformanceMark,\n  PerformanceMeasure,\n  PerformanceObserver,\n  PerformanceObserverEntryList,\n  PerformanceResourceTiming\n} from \"node:perf_hooks\";\nglobalThis.performance = performance;\nglobalThis.Performance = Performance;\nglobalThis.PerformanceEntry = PerformanceEntry;\nglobalThis.PerformanceMark = PerformanceMark;\nglobalThis.PerformanceMeasure = PerformanceMeasure;\nglobalThis.PerformanceObserver = PerformanceObserver;\nglobalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;\nglobalThis.PerformanceResourceTiming = PerformanceResourceTiming;\n","import { Writable } from \"node:stream\";\nimport noop from \"../mock/noop.mjs\";\nimport { notImplemented, notImplementedClass } from \"../_internal/utils.mjs\";\nconst _console = globalThis.console;\n// undocumented public APIs\nexport const _ignoreErrors = true;\nexport const _stderr = new Writable();\nexport const _stdout = new Writable();\nexport const log = _console?.log ?? noop;\nexport const info = _console?.info ?? log;\nexport const trace = _console?.trace ?? info;\nexport const debug = _console?.debug ?? log;\nexport const table = _console?.table ?? log;\nexport const error = _console?.error ?? log;\nexport const warn = _console?.warn ?? error;\n// https://developer.chrome.com/docs/devtools/console/api#createtask\nexport const createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented(\"console.createTask\");\nexport const assert = /* @__PURE__ */ notImplemented(\"console.assert\");\n// noop\nexport const clear = _console?.clear ?? noop;\nexport const count = _console?.count ?? noop;\nexport const countReset = _console?.countReset ?? noop;\nexport const dir = _console?.dir ?? noop;\nexport const dirxml = _console?.dirxml ?? noop;\nexport const group = _console?.group ?? noop;\nexport const groupEnd = _console?.groupEnd ?? noop;\nexport const groupCollapsed = _console?.groupCollapsed ?? noop;\nexport const profile = _console?.profile ?? noop;\nexport const profileEnd = _console?.profileEnd ?? noop;\nexport const time = _console?.time ?? noop;\nexport const timeEnd = _console?.timeEnd ?? noop;\nexport const timeLog = _console?.timeLog ?? noop;\nexport const timeStamp = _console?.timeStamp ?? noop;\nexport const Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass(\"console.Console\");\nexport const _times = /* @__PURE__ */ new Map();\nexport function context() {\n\t// TODO: Should be Console with all the methods\n\treturn _console;\n}\nexport const _stdoutErrorHandler = noop;\nexport const _stderrErrorHandler = noop;\nexport default {\n\t_times,\n\t_ignoreErrors,\n\t_stdoutErrorHandler,\n\t_stderrErrorHandler,\n\t_stdout,\n\t_stderr,\n\tassert,\n\tclear,\n\tConsole,\n\tcount,\n\tcountReset,\n\tdebug,\n\tdir,\n\tdirxml,\n\terror,\n\tcontext,\n\tcreateTask,\n\tgroup,\n\tgroupEnd,\n\tgroupCollapsed,\n\tinfo,\n\tlog,\n\tprofile,\n\tprofileEnd,\n\ttable,\n\ttime,\n\ttimeEnd,\n\ttimeLog,\n\ttimeStamp,\n\ttrace,\n\twarn\n};\n","export default Object.assign(() => {}, { __unenv__: true });\n","import {\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times,\n  Console\n} from \"unenv/node/console\";\nexport {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n} from \"unenv/node/console\";\nconst workerdConsole = globalThis[\"console\"];\nexport const {\n  assert,\n  clear,\n  // @ts-expect-error undocumented public API\n  context,\n  count,\n  countReset,\n  // @ts-expect-error undocumented public API\n  createTask,\n  debug,\n  dir,\n  dirxml,\n  error,\n  group,\n  groupCollapsed,\n  groupEnd,\n  info,\n  log,\n  profile,\n  profileEnd,\n  table,\n  time,\n  timeEnd,\n  timeLog,\n  timeStamp,\n  trace,\n  warn\n} = workerdConsole;\nObject.assign(workerdConsole, {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n});\nexport default workerdConsole;\n","import { default as defaultExport } from \"@cloudflare/unenv-preset/node/console\";\nglobalThis.console = defaultExport;","// https://nodejs.org/api/process.html#processhrtime\nexport const hrtime = /* @__PURE__ */ Object.assign(function hrtime(startTime) {\n\tconst now = Date.now();\n\t// millis to seconds\n\tconst seconds = Math.trunc(now / 1e3);\n\t// convert millis to nanos\n\tconst nanos = now % 1e3 * 1e6;\n\tif (startTime) {\n\t\tlet diffSeconds = seconds - startTime[0];\n\t\tlet diffNanos = nanos - startTime[0];\n\t\tif (diffNanos < 0) {\n\t\t\tdiffSeconds = diffSeconds - 1;\n\t\t\tdiffNanos = 1e9 + diffNanos;\n\t\t}\n\t\treturn [diffSeconds, diffNanos];\n\t}\n\treturn [seconds, nanos];\n}, { bigint: function bigint() {\n\t// Convert milliseconds to nanoseconds\n\treturn BigInt(Date.now() * 1e6);\n} });\n","import { EventEmitter } from \"node:events\";\nimport { ReadStream, WriteStream } from \"node:tty\";\nimport { notImplemented, createNotImplementedError } from \"../../../_internal/utils.mjs\";\n// node-version.ts is generated at build time\nimport { NODE_VERSION } from \"./node-version.mjs\";\nexport class Process extends EventEmitter {\n\tenv;\n\thrtime;\n\tnextTick;\n\tconstructor(impl) {\n\t\tsuper();\n\t\tthis.env = impl.env;\n\t\tthis.hrtime = impl.hrtime;\n\t\tthis.nextTick = impl.nextTick;\n\t\tfor (const prop of [...Object.getOwnPropertyNames(Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {\n\t\t\tconst value = this[prop];\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tthis[prop] = value.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\t// --- event emitter ---\n\temitWarning(warning, type, code) {\n\t\tconsole.warn(`${code ? `[${code}] ` : \"\"}${type ? `${type}: ` : \"\"}${warning}`);\n\t}\n\temit(...args) {\n\t\t// @ts-ignore\n\t\treturn super.emit(...args);\n\t}\n\tlisteners(eventName) {\n\t\treturn super.listeners(eventName);\n\t}\n\t// --- stdio (lazy initializers) ---\n\t#stdin;\n\t#stdout;\n\t#stderr;\n\tget stdin() {\n\t\treturn this.#stdin ??= new ReadStream(0);\n\t}\n\tget stdout() {\n\t\treturn this.#stdout ??= new WriteStream(1);\n\t}\n\tget stderr() {\n\t\treturn this.#stderr ??= new WriteStream(2);\n\t}\n\t// --- cwd ---\n\t#cwd = \"/\";\n\tchdir(cwd) {\n\t\tthis.#cwd = cwd;\n\t}\n\tcwd() {\n\t\treturn this.#cwd;\n\t}\n\t// --- dummy props and getters ---\n\tarch = \"\";\n\tplatform = \"\";\n\targv = [];\n\targv0 = \"\";\n\texecArgv = [];\n\texecPath = \"\";\n\ttitle = \"\";\n\tpid = 200;\n\tppid = 100;\n\tget version() {\n\t\treturn `v${NODE_VERSION}`;\n\t}\n\tget versions() {\n\t\treturn { node: NODE_VERSION };\n\t}\n\tget allowedNodeEnvironmentFlags() {\n\t\treturn new Set();\n\t}\n\tget sourceMapsEnabled() {\n\t\treturn false;\n\t}\n\tget debugPort() {\n\t\treturn 0;\n\t}\n\tget throwDeprecation() {\n\t\treturn false;\n\t}\n\tget traceDeprecation() {\n\t\treturn false;\n\t}\n\tget features() {\n\t\treturn {};\n\t}\n\tget release() {\n\t\treturn {};\n\t}\n\tget connected() {\n\t\treturn false;\n\t}\n\tget config() {\n\t\treturn {};\n\t}\n\tget moduleLoadList() {\n\t\treturn [];\n\t}\n\tconstrainedMemory() {\n\t\treturn 0;\n\t}\n\tavailableMemory() {\n\t\treturn 0;\n\t}\n\tuptime() {\n\t\treturn 0;\n\t}\n\tresourceUsage() {\n\t\treturn {};\n\t}\n\t// --- noop methods ---\n\tref() {\n\t\t// noop\n\t}\n\tunref() {\n\t\t// noop\n\t}\n\t// --- unimplemented methods ---\n\tumask() {\n\t\tthrow createNotImplementedError(\"process.umask\");\n\t}\n\tgetBuiltinModule() {\n\t\treturn undefined;\n\t}\n\tgetActiveResourcesInfo() {\n\t\tthrow createNotImplementedError(\"process.getActiveResourcesInfo\");\n\t}\n\texit() {\n\t\tthrow createNotImplementedError(\"process.exit\");\n\t}\n\treallyExit() {\n\t\tthrow createNotImplementedError(\"process.reallyExit\");\n\t}\n\tkill() {\n\t\tthrow createNotImplementedError(\"process.kill\");\n\t}\n\tabort() {\n\t\tthrow createNotImplementedError(\"process.abort\");\n\t}\n\tdlopen() {\n\t\tthrow createNotImplementedError(\"process.dlopen\");\n\t}\n\tsetSourceMapsEnabled() {\n\t\tthrow createNotImplementedError(\"process.setSourceMapsEnabled\");\n\t}\n\tloadEnvFile() {\n\t\tthrow createNotImplementedError(\"process.loadEnvFile\");\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"process.disconnect\");\n\t}\n\tcpuUsage() {\n\t\tthrow createNotImplementedError(\"process.cpuUsage\");\n\t}\n\tsetUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.setUncaughtExceptionCaptureCallback\");\n\t}\n\thasUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.hasUncaughtExceptionCaptureCallback\");\n\t}\n\tinitgroups() {\n\t\tthrow createNotImplementedError(\"process.initgroups\");\n\t}\n\topenStdin() {\n\t\tthrow createNotImplementedError(\"process.openStdin\");\n\t}\n\tassert() {\n\t\tthrow createNotImplementedError(\"process.assert\");\n\t}\n\tbinding() {\n\t\tthrow createNotImplementedError(\"process.binding\");\n\t}\n\t// --- attached interfaces ---\n\tpermission = { has: /* @__PURE__ */ notImplemented(\"process.permission.has\") };\n\treport = {\n\t\tdirectory: \"\",\n\t\tfilename: \"\",\n\t\tsignal: \"SIGUSR2\",\n\t\tcompact: false,\n\t\treportOnFatalError: false,\n\t\treportOnSignal: false,\n\t\treportOnUncaughtException: false,\n\t\tgetReport: /* @__PURE__ */ notImplemented(\"process.report.getReport\"),\n\t\twriteReport: /* @__PURE__ */ notImplemented(\"process.report.writeReport\")\n\t};\n\tfinalization = {\n\t\tregister: /* @__PURE__ */ notImplemented(\"process.finalization.register\"),\n\t\tunregister: /* @__PURE__ */ notImplemented(\"process.finalization.unregister\"),\n\t\tregisterBeforeExit: /* @__PURE__ */ notImplemented(\"process.finalization.registerBeforeExit\")\n\t};\n\tmemoryUsage = Object.assign(() => ({\n\t\tarrayBuffers: 0,\n\t\trss: 0,\n\t\texternal: 0,\n\t\theapTotal: 0,\n\t\theapUsed: 0\n\t}), { rss: () => 0 });\n\t// --- undefined props ---\n\tmainModule = undefined;\n\tdomain = undefined;\n\t// optional\n\tsend = undefined;\n\texitCode = undefined;\n\tchannel = undefined;\n\tgetegid = undefined;\n\tgeteuid = undefined;\n\tgetgid = undefined;\n\tgetgroups = undefined;\n\tgetuid = undefined;\n\tsetegid = undefined;\n\tseteuid = undefined;\n\tsetgid = undefined;\n\tsetgroups = undefined;\n\tsetuid = undefined;\n\t// internals\n\t_events = undefined;\n\t_eventsCount = undefined;\n\t_exiting = undefined;\n\t_maxListeners = undefined;\n\t_debugEnd = undefined;\n\t_debugProcess = undefined;\n\t_fatalException = undefined;\n\t_getActiveHandles = undefined;\n\t_getActiveRequests = undefined;\n\t_kill = undefined;\n\t_preload_modules = undefined;\n\t_rawDebug = undefined;\n\t_startProfilerIdleNotifier = undefined;\n\t_stopProfilerIdleNotifier = undefined;\n\t_tickCallback = undefined;\n\t_disconnect = undefined;\n\t_handleQueue = undefined;\n\t_pendingMessage = undefined;\n\t_channel = undefined;\n\t_send = undefined;\n\t_linkedBinding = undefined;\n}\n","export class ReadStream {\n\tfd;\n\tisRaw = false;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tsetRawMode(mode) {\n\t\tthis.isRaw = mode;\n\t\treturn this;\n\t}\n}\n","export class WriteStream {\n\tfd;\n\tcolumns = 80;\n\trows = 24;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tclearLine(dir, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tclearScreenDown(callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tcursorTo(x, y, callback) {\n\t\tcallback && typeof callback === \"function\" && callback();\n\t\treturn false;\n\t}\n\tmoveCursor(dx, dy, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tgetColorDepth(env) {\n\t\treturn 1;\n\t}\n\thasColors(count, env) {\n\t\treturn false;\n\t}\n\tgetWindowSize() {\n\t\treturn [this.columns, this.rows];\n\t}\n\twrite(str, encoding, cb) {\n\t\tif (str instanceof Uint8Array) {\n\t\t\tstr = new TextDecoder().decode(str);\n\t\t}\n\t\ttry {\n\t\t\tconsole.log(str);\n\t\t} catch {}\n\t\tcb && typeof cb === \"function\" && cb();\n\t\treturn false;\n\t}\n}\n","// Extracted from .nvmrc\nexport const NODE_VERSION = \"22.14.0\";\n","import { hrtime as UnenvHrTime } from \"unenv/node/internal/process/hrtime\";\nimport { Process as UnenvProcess } from \"unenv/node/internal/process/process\";\nconst globalProcess = globalThis[\"process\"];\nexport const getBuiltinModule = globalProcess.getBuiltinModule;\nconst workerdProcess = getBuiltinModule(\"node:process\");\nconst isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;\nconst unenvProcess = new UnenvProcess({\n  env: globalProcess.env,\n  // `hrtime` is only available from workerd process v2\n  hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : UnenvHrTime,\n  // `nextTick` is available from workerd process v1\n  nextTick: workerdProcess.nextTick\n});\nexport const { exit, features, platform } = workerdProcess;\nexport const {\n  // Always implemented by workerd\n  env,\n  // Only implemented in workerd v2\n  hrtime,\n  // Always implemented by workerd\n  nextTick\n} = unenvProcess;\nexport const {\n  _channel,\n  _disconnect,\n  _events,\n  _eventsCount,\n  _handleQueue,\n  _maxListeners,\n  _pendingMessage,\n  _send,\n  assert,\n  disconnect,\n  mainModule\n} = unenvProcess;\nexport const {\n  // @ts-expect-error `_debugEnd` is missing typings\n  _debugEnd,\n  // @ts-expect-error `_debugProcess` is missing typings\n  _debugProcess,\n  // @ts-expect-error `_exiting` is missing typings\n  _exiting,\n  // @ts-expect-error `_fatalException` is missing typings\n  _fatalException,\n  // @ts-expect-error `_getActiveHandles` is missing typings\n  _getActiveHandles,\n  // @ts-expect-error `_getActiveRequests` is missing typings\n  _getActiveRequests,\n  // @ts-expect-error `_kill` is missing typings\n  _kill,\n  // @ts-expect-error `_linkedBinding` is missing typings\n  _linkedBinding,\n  // @ts-expect-error `_preload_modules` is missing typings\n  _preload_modules,\n  // @ts-expect-error `_rawDebug` is missing typings\n  _rawDebug,\n  // @ts-expect-error `_startProfilerIdleNotifier` is missing typings\n  _startProfilerIdleNotifier,\n  // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings\n  _stopProfilerIdleNotifier,\n  // @ts-expect-error `_tickCallback` is missing typings\n  _tickCallback,\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  arch,\n  argv,\n  argv0,\n  availableMemory,\n  // @ts-expect-error `binding` is missing typings\n  binding,\n  channel,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  // @ts-expect-error `domain` is missing typings\n  domain,\n  emit,\n  emitWarning,\n  eventNames,\n  execArgv,\n  execPath,\n  exitCode,\n  finalization,\n  getActiveResourcesInfo,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getMaxListeners,\n  getuid,\n  hasUncaughtExceptionCaptureCallback,\n  // @ts-expect-error `initgroups` is missing typings\n  initgroups,\n  kill,\n  listenerCount,\n  listeners,\n  loadEnvFile,\n  memoryUsage,\n  // @ts-expect-error `moduleLoadList` is missing typings\n  moduleLoadList,\n  off,\n  on,\n  once,\n  // @ts-expect-error `openStdin` is missing typings\n  openStdin,\n  permission,\n  pid,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  // @ts-expect-error `reallyExit` is missing typings\n  reallyExit,\n  ref,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  send,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  setuid,\n  setUncaughtExceptionCaptureCallback,\n  sourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  throwDeprecation,\n  title,\n  traceDeprecation,\n  umask,\n  unref,\n  uptime,\n  version,\n  versions\n} = isWorkerdProcessV2 ? workerdProcess : unenvProcess;\nconst _process = {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  exit,\n  finalization,\n  features,\n  getBuiltinModule,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  nextTick,\n  on,\n  off,\n  once,\n  pid,\n  platform,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  // @ts-expect-error old API\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n};\nexport default _process;\n","import { default as defaultExport } from \"@cloudflare/unenv-preset/node/process\";\nglobalThis.process = defaultExport;","import { WorkerEntrypoint } from \"cloudflare:workers\";\nimport { PhotonImage, resize, SamplingFilter } from \"./lib\";\n\nconst transform = async (file: File, props: any = {}) => {\n\tconst inputImage = PhotonImage.new_from_image(file);\n\tconst outputImage = resize(inputImage, inputImage.get_width() * (scale / 100), inputImage.get_height() * (scale / 100), SamplingFilter.Nearest);\n};\n\nexport default class ImageProxy extends WorkerEntrypoint {\n\t// Currently, entrypoints without a named handler are not supported\n\tasync fetch() {\n\t\treturn new Response(null, { status: 404 });\n\t}\n\n\tasync transform(file: File, scale: number) {\n\t\tconst inputImage = PhotonImage.new_from_image(file);\n\t\tconst outputImage = resize(inputImage, inputImage.get_width() * (scale / 100), inputImage.get_height() * (scale / 100), SamplingFilter.Nearest);\n\n\t\tconst outputBytes = outputImage.get_bytes_webp();\n\n\t\tinputImage.free();\n\t\toutputImage.free();\n\n\t\treturn new Response(outputBytes as Uint8Array<ArrayBuffer>, {\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"image/webp\",\n\t\t\t},\n\t\t});\n\t\treturn file;\n\t}\n}\n","/* Polyfills ImageData constructor if it is not defined in globalThis object */\n\ninterface Settings {\n  colorSpace?: 'display-p3' | 'srgb';\n}\n\nconst globalObject = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : self;\n\nif (!('ImageData' in globalObject)) {\n  const widthMap = new WeakMap();\n  const heightMap = new WeakMap();\n  const colorSpaceMap = new WeakMap();\n  const colorSpaceEnum = ['display-p3', 'srgb'];\n\n  function getColorSpaceFromImageSettings(imageSettings?: unknown) {\n    if (typeof imageSettings !== 'undefined') {\n      if (typeof imageSettings !== 'object') {\n        throw new TypeError(\"Failed to construct 'ImageData': The provided value is not of type 'ImageDataSettings'.\");\n      }\n      if (imageSettings && 'colorSpace' in imageSettings && typeof imageSettings.colorSpace !== 'undefined') {\n        if (typeof imageSettings.colorSpace !== 'string' || !colorSpaceEnum.includes(imageSettings.colorSpace)) {\n          throw new TypeError(\n            `Failed to construct 'ImageData': Failed to read the 'colorSpace' property from 'ImageDataSettings': The provided value '${imageSettings.colorSpace}' is not a valid enum value of type PredefinedColorSpace.`,\n          );\n        }\n        return imageSettings.colorSpace;\n      }\n    }\n    // defaults to srgb\n    return 'srgb';\n  }\n\n  class ImageData {\n    constructor(...args: [Uint8ClampedArray | number, number, number | Settings | undefined, Settings | undefined]) {\n      let imageWidth: number;\n      let imageHeight: number;\n      let imageData: Uint8ClampedArray;\n      let imageColorSpace: string;\n\n      const [arg1, arg2, arg3, arg4] = args;\n\n      // At least 2 arguments are required\n      if (args.length < 2) {\n        throw new TypeError(`Failed to construct 'ImageData': 2 arguments required, but only ${args.length} present.`);\n      }\n\n      /**\n       * Case 1:\n       * Argument 1: (data) Uint8ClampedArray\n       * Argument 2: (width) number\n       * Argument 3: (height) number - Optional\n       * Argument 4: (settings) object - Optional\n       */\n      if (typeof arg1 === 'object') {\n        if (!(arg1 instanceof Uint8ClampedArray)) {\n          throw new TypeError(\"Failed to construct 'ImageData': parameter 1 is not of type 'Uint8ClampedArray'.\");\n        }\n\n        if (typeof arg2 !== 'number' || arg2 === 0) {\n          throw new Error(\"Failed to construct 'ImageData': The source width is zero or not a number.\");\n        }\n\n        imageData = arg1;\n        imageWidth = arg2 >>> 0;\n\n        if (imageWidth * 4 > imageData.length) {\n          throw new Error(\"Failed to construct 'ImageData': The requested image size exceeds the supported range.\");\n        }\n\n        if (imageData.length % 4 !== 0) {\n          throw new Error(\"Failed to construct 'ImageData': The input data length is not a multiple of 4.\");\n        }\n\n        if (imageData.length % (4 * imageWidth) !== 0) {\n          throw new Error(\"Failed to construct 'ImageData': The input data length is not a multiple of (4 * width).\");\n        }\n\n        if (typeof arg3 !== 'undefined') {\n          if (typeof arg3 !== 'number' || arg3 === 0) {\n            throw new Error(\"Failed to construct 'ImageData': The source height is zero or not a number.\");\n          }\n\n          imageHeight = arg3 >>> 0;\n\n          if (imageData.length % (4 * imageWidth * imageHeight) !== 0) {\n            throw new Error(\"Failed to construct 'ImageData': The input data length is not equal to (4 * width * height).\");\n          }\n        } else {\n          imageHeight = imageData.byteLength / imageWidth / 4;\n        }\n\n        imageColorSpace = getColorSpaceFromImageSettings(arg4);\n      } else {\n        /**\n         * Case 2:\n         * Argument 1: (width) number\n         * Argument 2: (height) number\n         * Argument 3: (settings) object - Optional\n         */\n        if (typeof arg1 !== 'number' || arg1 === 0) {\n          throw new Error(\"Failed to construct 'ImageData': The source width is zero or not a number.\");\n        }\n\n        imageWidth = arg1 >>> 0;\n\n        if (typeof arg2 !== 'number' || arg2 === 0) {\n          throw new Error(\"Failed to construct 'ImageData': The source height is zero or not a number.\");\n        }\n\n        imageHeight = arg2 >>> 0;\n\n        if (imageWidth * imageHeight >= 1 << 30) {\n          throw new Error(\"Failed to construct 'ImageData': The requested image size exceeds the supported range.\");\n        }\n\n        imageData = new Uint8ClampedArray(imageWidth * imageHeight * 4);\n        imageColorSpace = getColorSpaceFromImageSettings(arg3);\n      }\n\n      widthMap.set(this, imageWidth);\n      heightMap.set(this, imageHeight);\n      colorSpaceMap.set(this, imageColorSpace);\n      Object.defineProperty(this, 'data', {\n        configurable: true,\n        enumerable: true,\n        value: imageData,\n        writable: false,\n      });\n    }\n  }\n\n  Object.defineProperty(ImageData.prototype, 'width', {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return widthMap.get(this);\n    },\n  });\n\n  Object.defineProperty(ImageData.prototype, 'height', {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return heightMap.get(this);\n    },\n  });\n\n  Object.defineProperty(ImageData.prototype, 'colorSpace', {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return colorSpaceMap.get(this);\n    },\n  });\n\n  (globalObject as { ImageData: typeof ImageData }).ImageData = ImageData;\n}\n\nexport const ImageData = globalObject.ImageData;\n","let wasm;\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_2.set(idx, obj);\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        const idx = addToExternrefTable0(e);\n        wasm.__wbindgen_exn_store(idx);\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nlet cachedUint8ClampedArrayMemory0 = null;\n\nfunction getUint8ClampedArrayMemory0() {\n    if (cachedUint8ClampedArrayMemory0 === null || cachedUint8ClampedArrayMemory0.byteLength === 0) {\n        cachedUint8ClampedArrayMemory0 = new Uint8ClampedArray(wasm.memory.buffer);\n    }\n    return cachedUint8ClampedArrayMemory0;\n}\n\nfunction getClampedArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ClampedArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n/**\n * Alter a select channel by incrementing or decrementing its value by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel` - The channel you wish to alter, it should be either 0, 1 or 2,\n * representing R, G, or B respectively. (O=Red, 1=Green, 2=Blue)\n * * `amount` - The amount to increment/decrement the channel's value by for that pixel.\n * A positive value will increment/decrement the channel's value, a negative value will decrement the channel's value.\n *\n * ## Example\n *\n * ```no_run\n * // For example, to increase the Red channel for all pixels by 10:\n * use photon_rs::channels::alter_channel;\n * use photon_rs::native::{open_image};\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_channel(&mut img, 0_usize, 10_i16);\n * ```\n *\n * Adds a constant to a select R, G, or B channel's value.\n *\n * ### Decrease a channel's value\n * // For example, to decrease the Green channel for all pixels by 20:\n * ```no_run\n * use photon_rs::channels::alter_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_channel(&mut img, 1_usize, -20_i16);\n * ```\n * **Note**: Note the use of a minus symbol when decreasing the channel.\n * @param {PhotonImage} img\n * @param {number} channel\n * @param {number} amt\n */\nexport function alter_channel(img, channel, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_channel(img.__wbg_ptr, channel, amt);\n}\n\n/**\n * Increment or decrement every pixel's Red channel by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Red channel for all pixels by 10:\n * use photon_rs::channels::alter_red_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_red_channel(&mut img, 10_i16);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} amt\n */\nexport function alter_red_channel(photon_image, amt) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.alter_red_channel(photon_image.__wbg_ptr, amt);\n}\n\n/**\n * Increment or decrement every pixel's Green channel by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `amt` - The amount to increment/decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Green channel for all pixels by 20:\n * use photon_rs::channels::alter_green_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_green_channel(&mut img, 20_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} amt\n */\nexport function alter_green_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_green_channel(img.__wbg_ptr, amt);\n}\n\n/**\n * Increment or decrement every pixel's Blue channel by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Blue channel for all pixels by 10:\n * use photon_rs::channels::alter_blue_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_blue_channel(&mut img, 10_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} amt\n */\nexport function alter_blue_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_blue_channel(img.__wbg_ptr, amt);\n}\n\n/**\n * Increment/decrement two channels' values simultaneously by adding an amt to each channel per pixel.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel1` - A usize from 0 to 2 that represents either the R, G or B channels.\n * * `amt1` - The amount to increment/decrement the channel's value by for that pixel.\n * * `channel2` -A usize from 0 to 2 that represents either the R, G or B channels.\n * * `amt2` - The amount to increment/decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the values of the Red and Blue channels per pixel:\n * use photon_rs::channels::alter_two_channels;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_two_channels(&mut img, 0_usize, 10_i16, 2_usize, 20_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} channel1\n * @param {number} amt1\n * @param {number} channel2\n * @param {number} amt2\n */\nexport function alter_two_channels(img, channel1, amt1, channel2, amt2) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_two_channels(img.__wbg_ptr, channel1, amt1, channel2, amt2);\n}\n\n/**\n * Increment all 3 channels' values by adding an amt to each channel per pixel.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `r_amt` - The amount to increment/decrement the Red channel by.\n * * `g_amt` - The amount to increment/decrement the Green channel by.\n * * `b_amt` - The amount to increment/decrement the Blue channel by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the values of the Red channel by 10, the Green channel by 20,\n * // and the Blue channel by 50:\n * use photon_rs::channels::alter_channels;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_channels(&mut img, 10_i16, 20_i16, 50_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} r_amt\n * @param {number} g_amt\n * @param {number} b_amt\n */\nexport function alter_channels(img, r_amt, g_amt, b_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_channels(img.__wbg_ptr, r_amt, g_amt, b_amt);\n}\n\n/**\n * Set a certain channel to zero, thus removing the channel's influence in the pixels' final rendered colour.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel` - The channel to be removed; must be a usize from 0 to 2, with 0 representing Red, 1 representing Green, and 2 representing Blue.\n * * `min_filter` - Minimum filter. Value between 0 and 255. Only remove the channel if the current pixel's channel value is less than this minimum filter. To completely\n * remove the channel, set this value to 255, to leave the channel as is, set to 0, and to set a channel to zero for a pixel whose red value is greater than 50,\n * then channel would be 0 and min_filter would be 50.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the Red channel with a min_filter of 100:\n * use photon_rs::channels::remove_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_channel(&mut img, 0_usize, 100_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} channel\n * @param {number} min_filter\n */\nexport function remove_channel(img, channel, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_channel(img.__wbg_ptr, channel, min_filter);\n}\n\n/**\n * Remove the Red channel's influence in an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the red channel for red channel pixel values less than 50:\n * use photon_rs::channels::remove_red_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_red_channel(&mut img, 50_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} min_filter\n */\nexport function remove_red_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_red_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n * Remove the Green channel's influence in an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the green channel for green channel pixel values less than 50:\n * use photon_rs::channels::remove_green_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_green_channel(&mut img, 50_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} min_filter\n */\nexport function remove_green_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_green_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n * Remove the Blue channel's influence in an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the blue channel for blue channel pixel values less than 50:\n * use photon_rs::channels::remove_blue_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_blue_channel(&mut img, 50_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} min_filter\n */\nexport function remove_blue_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_blue_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n * Swap two channels.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel1` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Red would be represented by 0, Green by 1, and Blue by 2.\n * * `channel2` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Same as above.\n *\n * # Example\n *\n * ```no_run\n * // For example, to swap the values of the Red channel with the values of the Blue channel:\n * use photon_rs::channels::swap_channels;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * swap_channels(&mut img, 0_usize, 2_usize);\n * ```\n * @param {PhotonImage} img\n * @param {number} channel1\n * @param {number} channel2\n */\nexport function swap_channels(img, channel1, channel2) {\n    _assertClass(img, PhotonImage);\n    wasm.swap_channels(img.__wbg_ptr, channel1, channel2);\n}\n\n/**\n * Invert RGB value of an image.\n *\n * # Arguments\n * * `photon_image` - A DynamicImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * use photon_rs::channels::invert;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * invert(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function invert(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.invert(photon_image.__wbg_ptr);\n}\n\n/**\n * Selective hue rotation.\n *\n * Only rotate the hue of a pixel if its RGB values are within a specified range.\n * This function only rotates a pixel's hue to another  if it is visually similar to the colour specified.\n * For example, if a user wishes all pixels that are blue to be changed to red, they can selectively specify  only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `degrees` - The amount of degrees to hue rotate by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to only rotate the pixels that are of RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_hue_rotate;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_hue_rotate(&mut img, ref_color, 180_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} ref_color\n * @param {number} degrees\n */\nexport function selective_hue_rotate(photon_image, ref_color, degrees) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_hue_rotate(photon_image.__wbg_ptr, ptr0, degrees);\n}\n\n/**\n * Selectively change pixel colours which are similar to the reference colour provided.\n *\n * Similarity between two colours is calculated via the CIE76 formula.\n * Only changes the color of a pixel if its similarity to the reference colour is within the range in the algorithm.\n * For example, with this function, a user can change the color of all blue pixels by mixing them with red by 10%.\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `new_color` - The `RGB` value of the new color (to be mixed with the matched pixels)\n * * `fraction` - The amount of mixing the new colour with the matched pixels\n *\n * # Example\n *\n * ```no_run\n * // For example, to only change the color of pixels that are similar to the RGB value RGB{200, 120, 30} by mixing RGB{30, 120, 200} with 25%:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_color_convert;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(200, 120, 30);\n * let new_color = Rgb::new(30, 120, 200);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_color_convert(&mut img, ref_color, new_color, 0.25);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} ref_color\n * @param {Rgb} new_color\n * @param {number} fraction\n */\nexport function selective_color_convert(photon_image, ref_color, new_color, fraction) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    _assertClass(new_color, Rgb);\n    var ptr1 = new_color.__destroy_into_raw();\n    wasm.selective_color_convert(photon_image.__wbg_ptr, ptr0, ptr1, fraction);\n}\n\n/**\n * Selectively lighten an image.\n *\n * Only lighten the hue of a pixel if its colour matches or is similar to the RGB colour specified.\n * For example, if a user wishes all pixels that are blue to be lightened, they can selectively specify  only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `amt` - The level from 0 to 1 to lighten the hue by. Increasing by 10% would have an `amt` of 0.1\n *\n * # Example\n *\n * ```no_run\n * // For example, to only lighten the pixels that are of or similar to RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_lighten;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_lighten(&mut img, ref_color, 0.2_f32);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} ref_color\n * @param {number} amt\n */\nexport function selective_lighten(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_lighten(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n * Selectively desaturate pixel colours which are similar to the reference colour provided.\n *\n * Similarity between two colours is calculated via the CIE76 formula.\n * Only desaturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n * For example, if a user wishes all pixels that are blue to be desaturated by 0.1, they can selectively specify  only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `amt` - The amount of desaturate the colour by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to only desaturate the pixels that are similar to the RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_desaturate;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_desaturate(&mut img, ref_color, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} ref_color\n * @param {number} amt\n */\nexport function selective_desaturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_desaturate(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n * Selectively saturate pixel colours which are similar to the reference colour provided.\n *\n * Similarity between two colours is calculated via the CIE76 formula.\n * Only saturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n * For example, if a user wishes all pixels that are blue to have an increase in saturation by 10%, they can selectively specify only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `amt` - The amount of saturate the colour by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to only increase the saturation of pixels that are similar to the RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_saturate;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_saturate(&mut img, ref_color, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} ref_color\n * @param {number} amt\n */\nexport function selective_saturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_saturate(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n * Selectively changes a pixel to greyscale if it is *not* visually similar or close to the colour specified.\n * Only changes the colour of a pixel if its RGB values are within a specified range.\n *\n * (Similarity between two colours is calculated via the CIE76 formula.)\n * For example, if a user wishes all pixels that are *NOT* blue to be displayed in greyscale, they can selectively specify only the blue pixels to be\n * kept in the photo.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n *\n * # Example\n *\n * ```no_run\n * // For example, to greyscale all pixels that are *not* visually similar to the RGB colour RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_greyscale;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_greyscale(img, ref_color);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} ref_color\n */\nexport function selective_greyscale(photon_image, ref_color) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = photon_image.__destroy_into_raw();\n    _assertClass(ref_color, Rgb);\n    var ptr1 = ref_color.__destroy_into_raw();\n    wasm.selective_greyscale(ptr0, ptr1);\n}\n\n/**\n * Apply a monochrome effect of a certain colour.\n *\n * It does so by averaging the R, G, and B values of a pixel, and then adding a\n * separate value to that averaged value for each channel to produce a tint.\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `r_offset` - The value to add to the Red channel per pixel.\n * * `g_offset` - The value to add to the Green channel per pixel.\n * * `b_offset` - The value to add to the Blue channel per pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a monochrome effect to an image:\n * use photon_rs::monochrome::monochrome;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * monochrome(&mut img, 40_u32, 50_u32, 100_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} r_offset\n * @param {number} g_offset\n * @param {number} b_offset\n */\nexport function monochrome(img, r_offset, g_offset, b_offset) {\n    _assertClass(img, PhotonImage);\n    wasm.monochrome(img.__wbg_ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n * Convert an image to sepia.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to sepia an image of type `PhotonImage`:\n * use photon_rs::monochrome::sepia;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sepia(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function sepia(img) {\n    _assertClass(img, PhotonImage);\n    wasm.sepia(img.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale using the conventional averaging algorithm.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to convert an image of type `PhotonImage` to grayscale:\n * use photon_rs::monochrome::grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * grayscale(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function grayscale(img) {\n    _assertClass(img, PhotonImage);\n    wasm.grayscale(img.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale with a human corrected factor, to account for human vision.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to convert an image of type `PhotonImage` to grayscale with a human corrected factor:\n * use photon_rs::monochrome::grayscale_human_corrected;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * grayscale_human_corrected(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function grayscale_human_corrected(img) {\n    _assertClass(img, PhotonImage);\n    wasm.grayscale_human_corrected(img.__wbg_ptr);\n}\n\n/**\n * Desaturate an image by getting the min/max of each pixel's RGB values.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to desaturate an image:\n * use photon_rs::monochrome::desaturate;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function desaturate(img) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate(img.__wbg_ptr);\n}\n\n/**\n * Uses a min. decomposition algorithm to convert an image to greyscale.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to decompose an image with min decomposition:\n * use photon_rs::monochrome::decompose_min;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * decompose_min(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function decompose_min(img) {\n    _assertClass(img, PhotonImage);\n    wasm.decompose_min(img.__wbg_ptr);\n}\n\n/**\n * Uses a max. decomposition algorithm to convert an image to greyscale.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to decompose an image with max decomposition:\n * use photon_rs::monochrome::decompose_max;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * decompose_max(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function decompose_max(img) {\n    _assertClass(img, PhotonImage);\n    wasm.decompose_max(img.__wbg_ptr);\n}\n\n/**\n * Employ only a limited number of gray shades in an image.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `num_shades` - The number of grayscale shades to be displayed in the image.\n *\n * # Example\n *\n * ```no_run\n * // For example, to limit an image to four shades of gray only:\n * use photon_rs::monochrome::grayscale_shades;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * grayscale_shades(&mut img, 4_u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_shades\n */\nexport function grayscale_shades(photon_image, num_shades) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.grayscale_shades(photon_image.__wbg_ptr, num_shades);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to the Red channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * use photon_rs::monochrome::r_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * r_grayscale(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function r_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.r_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to the Green channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * use photon_rs::monochrome::g_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * g_grayscale(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function g_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.g_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to the Blue channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * use photon_rs::monochrome::b_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * b_grayscale(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function b_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.b_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to a chosen channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `channel` - A usize representing the channel from 0 to 2. O represents the Red channel, 1 the Green channel, and 2 the Blue channel.\n *\n * # Example\n * To grayscale using only values from the Red channel:\n * ```no_run\n * use photon_rs::monochrome::single_channel_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * single_channel_grayscale(&mut img, 0_usize);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} channel\n */\nexport function single_channel_grayscale(photon_image, channel) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.single_channel_grayscale(photon_image.__wbg_ptr, channel);\n}\n\n/**\n * Threshold an image using a standard thresholding algorithm.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `threshold` - The amount the image should be thresholded by from 0 to 255.\n * # Example\n *\n * ```no_run\n * // For example, to threshold an image of type `PhotonImage`:\n * use photon_rs::monochrome::threshold;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * threshold(&mut img, 30_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} threshold\n */\nexport function threshold(img, threshold) {\n    _assertClass(img, PhotonImage);\n    wasm.threshold(img.__wbg_ptr, threshold);\n}\n\n/**\n * Applies gamma correction to an image.\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `red` - Gamma value for red channel.\n * * `green` - Gamma value for green channel.\n * * `blue` - Gamma value for blue channel.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a gamma corrected image:\n * use photon_rs::colour_spaces::gamma_correction;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * gamma_correction(&mut img, 2.2, 2.2, 2.2);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n */\nexport function gamma_correction(photon_image, red, green, blue) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.gamma_correction(photon_image.__wbg_ptr, red, green, blue);\n}\n\n/**\n * Image manipulation effects in the HSLuv colour space\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hsluv(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function hsluv(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsluv(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Image manipulation effects in the LCh colour space\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lch(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function lch(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.lch(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Image manipulation effects in the HSL colour space.\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hsl(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function hsl(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsl(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Image manipulation in the HSV colour space.\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n *\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hsv(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function hsv(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsv(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Shift hue by a specified number of degrees in the HSL colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n * use photon_rs::colour_spaces::hue_rotate_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_hsl(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_hsl(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsl(img.__wbg_ptr, degrees);\n}\n\n/**\n * Shift hue by a specified number of degrees in the HSV colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSV colour space:\n * use photon_rs::colour_spaces::hue_rotate_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_hsv(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_hsv(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsv(img.__wbg_ptr, degrees);\n}\n\n/**\n * Shift hue by a specified number of degrees in the LCh colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n * use photon_rs::colour_spaces::hue_rotate_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_lch(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_lch(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_lch(img.__wbg_ptr, degrees);\n}\n\n/**\n * Shift hue by a specified number of degrees in the HSLuv colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n * use photon_rs::colour_spaces::hue_rotate_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_hsluv(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_hsluv(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsluv(img.__wbg_ptr, degrees);\n}\n\n/**\n * Increase the image's saturation by converting each pixel's colour to the HSL colour space\n * and increasing the colour's saturation.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 10% in the HSL colour space:\n * use photon_rs::colour_spaces::saturate_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Increase the image's saturation in the LCh colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 40% in the Lch colour space:\n * use photon_rs::colour_spaces::saturate_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_lch(&mut img, 0.4_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Increase the image's saturation in the HSLuv colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 40% in the HSLuv colour space:\n * use photon_rs::colour_spaces::saturate_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_hsluv(&mut img, 0.4_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Increase the image's saturation in the HSV colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level by which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 30% in the HSV colour space:\n * use photon_rs::colour_spaces::saturate_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_hsv(&mut img, 0.3_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the LCh colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::lighten_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_lch(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the HSLuv colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the HSLuv colour space:\n * use photon_rs::colour_spaces::lighten_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_hsluv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the HSL colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the HSL colour space:\n * use photon_rs::colour_spaces::lighten_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the HSV colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the HSV colour space:\n * use photon_rs::colour_spaces::lighten_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_hsv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image by a specified amount in the LCh colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::darken_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_lch(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image by a specified amount in the HSLuv colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the HSLuv colour space:\n * use photon_rs::colour_spaces::darken_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_hsluv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image by a specified amount in the HSL colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the HSL colour space:\n * use photon_rs::colour_spaces::darken_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image's colours by a specified amount in the HSV colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the HSV colour space:\n * use photon_rs::colour_spaces::darken_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_hsv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the HSV colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the HSV colour space:\n * use photon_rs::colour_spaces::desaturate_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_hsv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the HSL colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::desaturate_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the LCh colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::desaturate_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_lch(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the HSLuv colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the HSLuv colour space:\n * use photon_rs::colour_spaces::desaturate_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_hsluv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Mix image with a single color, supporting passing `opacity`.\n * The algorithm comes from Jimp. See `function mix` and `function colorFn` at following link:\n * https://github.com/oliver-moran/jimp/blob/29679faa597228ff2f20d34c5758e4d2257065a3/packages/plugin-color/src/index.js\n * Specifically, result_value = (mix_color_value - origin_value) * opacity + origin_value =\n * mix_color_value * opacity + (1 - opacity) * origin_value for each\n * of RGB channel.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `mix_color` - the color to be mixed in, as an RGB value.\n * * `opacity` - the opacity of color when mixed to image. Float value from 0 to 1.\n * # Example\n *\n * ```no_run\n * // For example, to mix an image with rgb (50, 255, 254) and opacity 0.4:\n * use photon_rs::Rgb;\n * use photon_rs::colour_spaces::mix_with_colour;\n * use photon_rs::native::open_image;\n *\n * let mix_colour = Rgb::new(50_u8, 255_u8, 254_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * mix_with_colour(&mut img, mix_colour, 0.4_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} mix_colour\n * @param {number} opacity\n */\nexport function mix_with_colour(photon_image, mix_colour, opacity) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(mix_colour, Rgb);\n    var ptr0 = mix_colour.__destroy_into_raw();\n    wasm.mix_with_colour(photon_image.__wbg_ptr, ptr0, opacity);\n}\n\n/**\n * Noise reduction.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to noise reduct an image:\n * use photon_rs::conv::noise_reduction;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * noise_reduction(&mut img);\n * ```\n * Adds a constant to a select R, G, or B channel's value.\n * @param {PhotonImage} photon_image\n */\nexport function noise_reduction(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.noise_reduction(photon_image.__wbg_ptr);\n}\n\n/**\n * Sharpen an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to sharpen an image:\n * use photon_rs::conv::sharpen;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sharpen(&mut img);\n * ```\n * Adds a constant to a select R, G, or B channel's value.\n * @param {PhotonImage} photon_image\n */\nexport function sharpen(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sharpen(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply edge detection to an image, to create a dark version with its edges highlighted.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Red channel for all pixels by 10:\n * use photon_rs::conv::edge_detection;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * edge_detection(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function edge_detection(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.edge_detection(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply an identity kernel convolution to an image.\n *\n * # Arguments\n * * `img` -A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply an identity kernel convolution:\n * use photon_rs::conv::identity;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * identity(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function identity(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.identity(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a box blur effect.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a box blur effect:\n * use photon_rs::conv::box_blur;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * box_blur(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function box_blur(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.box_blur(photon_image.__wbg_ptr);\n}\n\n/**\n * Gaussian blur in linear time.\n *\n * Reference: http://blog.ivank.net/fastest-gaussian-blur.html\n *\n * # Arguments\n * * `photon_image` - A PhotonImage\n * * `radius` - blur radius\n * # Example\n *\n * ```no_run\n * use photon_rs::conv::gaussian_blur;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * gaussian_blur(&mut img, 3_i32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} radius\n */\nexport function gaussian_blur(photon_image, radius) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.gaussian_blur(photon_image.__wbg_ptr, radius);\n}\n\n/**\n * Detect horizontal lines in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the horizontal lines in an image:\n * use photon_rs::conv::detect_horizontal_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_horizontal_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_horizontal_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_horizontal_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Detect vertical lines in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the vertical lines in an image:\n * use photon_rs::conv::detect_vertical_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_vertical_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_vertical_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_vertical_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Detect lines at a forty five degree angle in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the lines at a forty five degree angle in an image:\n * use photon_rs::conv::detect_45_deg_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_45_deg_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_45_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_45_deg_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Detect lines at a 135 degree angle in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the lines at a 135 degree angle in an image:\n * use photon_rs::conv::detect_135_deg_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_135_deg_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_135_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_135_deg_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a standard laplace convolution.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a laplace effect:\n * use photon_rs::conv::laplace;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * laplace(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function laplace(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.laplace(photon_image.__wbg_ptr);\n}\n\n/**\n * Preset edge effect.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply this effect:\n * use photon_rs::conv::edge_one;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * edge_one(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function edge_one(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.edge_one(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply an emboss effect to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply an emboss effect:\n * use photon_rs::conv::emboss;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * emboss(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function emboss(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.emboss(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a horizontal Sobel filter to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a horizontal Sobel filter:\n * use photon_rs::conv::sobel_horizontal;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sobel_horizontal(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function sobel_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_horizontal(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a horizontal Prewitt convolution to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a horizontal Prewitt convolution effect:\n * use photon_rs::conv::prewitt_horizontal;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * prewitt_horizontal(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function prewitt_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.prewitt_horizontal(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a vertical Sobel filter to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a vertical Sobel filter:\n * use photon_rs::conv::sobel_vertical;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sobel_vertical(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function sobel_vertical(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_vertical(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a global Sobel filter to an image\n *\n * Each pixel is calculated as the magnitude of the horizontal and vertical components of the Sobel filter,\n * ie if X is the horizontal sobel and Y is the vertical, for each pixel, we calculate sqrt(X^2 + Y^2)\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a global Sobel filter:\n * use photon_rs::conv::sobel_global;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sobel_global(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function sobel_global(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_global(photon_image.__wbg_ptr);\n}\n\n/**\n * Add randomized noise to an image.\n * This function adds a Gaussian Noise Sample to each pixel through incrementing each channel by a randomized offset.\n * This randomized offset is generated by creating a randomized thread pool.\n * **[WASM SUPPORT IS AVAILABLE]**: Randomized thread pools cannot be created with WASM, but\n * a workaround using js_sys::Math::random works now.\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example:\n * use photon_rs::native::open_image;\n * use photon_rs::noise::add_noise_rand;\n * use photon_rs::PhotonImage;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * add_noise_rand(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function add_noise_rand(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.add_noise_rand(photon_image.__wbg_ptr);\n}\n\n/**\n * Add pink-tinted noise to an image.\n *\n * **[WASM SUPPORT IS AVAILABLE]**: Randomized thread pools cannot be created with WASM, but\n * a workaround using js_sys::Math::random works now.\n * # Arguments\n * * `name` - A PhotonImage that contains a view into the image.\n *\n * # Example\n *\n * ```no_run\n * // For example, to add pink-tinted noise to an image:\n * use photon_rs::native::open_image;\n * use photon_rs::noise::pink_noise;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * pink_noise(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function pink_noise(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.pink_noise(photon_image.__wbg_ptr);\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_export_2.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n/**\n * ! [temp] Check if WASM is supported.\n */\nexport function run() {\n    const ret = wasm.run();\n    if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n    }\n}\n\n/**\n * Get the ImageData from a 2D canvas context\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} ctx\n * @returns {ImageData}\n */\nexport function get_image_data(canvas, ctx) {\n    const ret = wasm.get_image_data(canvas, ctx);\n    return ret;\n}\n\n/**\n * Place a PhotonImage onto a 2D canvas.\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} ctx\n * @param {PhotonImage} new_image\n */\nexport function putImageData(canvas, ctx, new_image) {\n    _assertClass(new_image, PhotonImage);\n    var ptr0 = new_image.__destroy_into_raw();\n    wasm.putImageData(canvas, ctx, ptr0);\n}\n\n/**\n * Convert a HTML5 Canvas Element to a PhotonImage.\n *\n * This converts the ImageData found in the canvas context to a PhotonImage,\n * which can then have effects or filters applied to it.\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} ctx\n * @returns {PhotonImage}\n */\nexport function open_image(canvas, ctx) {\n    const ret = wasm.open_image(canvas, ctx);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Convert ImageData to a raw pixel vec of u8s.\n * @param {ImageData} imgdata\n * @returns {Uint8Array}\n */\nexport function to_raw_pixels(imgdata) {\n    const ret = wasm.to_raw_pixels(imgdata);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n}\n\n/**\n * Convert a base64 string to a PhotonImage.\n * @param {string} base64\n * @returns {PhotonImage}\n */\nexport function base64_to_image(base64) {\n    const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.base64_to_image(ptr0, len0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Convert a base64 string to a Vec of u8s.\n * @param {string} base64\n * @returns {Uint8Array}\n */\nexport function base64_to_vec(base64) {\n    const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.base64_to_vec(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Convert a PhotonImage to JS-compatible ImageData.\n * @param {PhotonImage} photon_image\n * @returns {ImageData}\n */\nexport function to_image_data(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = photon_image.__destroy_into_raw();\n    const ret = wasm.to_image_data(ptr0);\n    return ret;\n}\n\n/**\n * Add bordered-text to an image.\n * The only font available as of now is Roboto.\n * Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `text` - Text string to be drawn to the image.\n * * `x` - x-coordinate of where first letter's 1st pixel should be drawn.\n * * `y` - y-coordinate of where first letter's 1st pixel should be drawn.\n * * `font_size` - Font size in pixels of the text to be drawn.\n *\n * # Example\n *\n * ```no_run\n * // For example to draw the string \"Welcome to Photon!\" at 10, 10:\n * use photon_rs::native::open_image;\n * use photon_rs::text::draw_text_with_border;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * draw_text_with_border(&mut img, \"Welcome to Photon!\", 10_i32, 10_i32, 90_f32);\n * ```\n * @param {PhotonImage} photon_img\n * @param {string} text\n * @param {number} x\n * @param {number} y\n * @param {number} font_size\n */\nexport function draw_text_with_border(photon_img, text, x, y, font_size) {\n    _assertClass(photon_img, PhotonImage);\n    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.draw_text_with_border(photon_img.__wbg_ptr, ptr0, len0, x, y, font_size);\n}\n\n/**\n * Add text to an image.\n * The only font available as of now is Roboto.\n * Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `text` - Text string to be drawn to the image.\n * * `x` - x-coordinate of where first letter's 1st pixel should be drawn.\n * * `y` - y-coordinate of where first letter's 1st pixel should be drawn.\n * * `font_size` - Font size in pixels of the text to be drawn.\n *\n * # Example\n *\n * ```no_run\n * // For example to draw the string \"Welcome to Photon!\" at 10, 10:\n * use photon_rs::native::open_image;\n * use photon_rs::text::draw_text;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * draw_text(&mut img, \"Welcome to Photon!\", 10_i32, 10_i32, 90_f32);\n * ```\n * @param {PhotonImage} photon_img\n * @param {string} text\n * @param {number} x\n * @param {number} y\n * @param {number} font_size\n */\nexport function draw_text(photon_img, text, x, y, font_size) {\n    _assertClass(photon_img, PhotonImage);\n    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.draw_text(photon_img.__wbg_ptr, ptr0, len0, x, y, font_size);\n}\n\n/**\n * Add a watermark to an image.\n *\n * # Arguments\n * * `img` - A DynamicImage that contains a view into the image.\n * * `watermark` - The watermark to be placed onto the `img` image.\n * * `x` - The x coordinate where the watermark's top corner should be positioned.\n * * `y` - The y coordinate where the watermark's top corner should be positioned.\n * # Example\n *\n * ```no_run\n * // For example, to add a watermark to an image at x: 30, y: 40:\n * use photon_rs::multiple::watermark;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let water_mark = open_image(\"watermark.jpg\").expect(\"File should open\");\n * watermark(&mut img, &water_mark, 30_i64, 40_i64);\n * ```\n * @param {PhotonImage} img\n * @param {PhotonImage} watermark\n * @param {bigint} x\n * @param {bigint} y\n */\nexport function watermark(img, watermark, x, y) {\n    _assertClass(img, PhotonImage);\n    _assertClass(watermark, PhotonImage);\n    wasm.watermark(img.__wbg_ptr, watermark.__wbg_ptr, x, y);\n}\n\n/**\n * Blend two images together.\n *\n * The `blend_mode` (3rd param) determines which blending mode to use; change this for varying effects.\n * The blend modes available include: `overlay`, `over`, `atop`, `xor`, `plus`, `multiply`, `burn`,\n * `difference`, `soft_light`, `screen`, `hard_light`, `dodge`, `exclusion`, `lighten`, `darken` (more to come)\n * NOTE: The first image must be smaller than the second image passed as params.\n * If the first image were larger than the second, then there would be overflowing pixels which would have no corresponding pixels\n * in the second image.\n * # Arguments\n * * `img` - A DynamicImage that contains a view into the image.\n * * `img2` - The 2nd DynamicImage to be blended with the first.\n * * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n * # Example\n *\n * ```no_run\n * // For example, to blend two images with the `multiply` blend mode:\n * use photon_rs::multiple::blend;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let img2 = open_image(\"img2.jpg\").expect(\"File should open\");\n * blend(&mut img, &img2, \"multiply\");\n * ```\n * @param {PhotonImage} photon_image\n * @param {PhotonImage} photon_image2\n * @param {string} blend_mode\n */\nexport function blend(photon_image, photon_image2, blend_mode) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(photon_image2, PhotonImage);\n    const ptr0 = passStringToWasm0(blend_mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.blend(photon_image.__wbg_ptr, photon_image2.__wbg_ptr, ptr0, len0);\n}\n\n/**\n * @param {number} width\n * @param {number} height\n * @returns {PhotonImage}\n */\nexport function create_gradient(width, height) {\n    const ret = wasm.create_gradient(width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply a gradient to an image.\n * @param {PhotonImage} image\n */\nexport function apply_gradient(image) {\n    _assertClass(image, PhotonImage);\n    wasm.apply_gradient(image.__wbg_ptr);\n}\n\n/**\n * Solarization on the Blue channel.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::neue;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * neue(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function neue(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.neue(photon_image.__wbg_ptr);\n}\n\n/**\n * Solarization on the Red and Green channels.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::lix;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lix(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function lix(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.lix(photon_image.__wbg_ptr);\n}\n\n/**\n * Solarization on the Red and Blue channels.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::ryo;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * ryo(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function ryo(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.ryo(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a filter to an image. Over 20 filters are available.\n * The filters are as follows:\n * * **oceanic**: Add an aquamarine-tinted hue to an image.\n * * **islands**: Aquamarine tint.\n * * **marine**: Add a green/blue mixed hue to an image.\n * * **seagreen**: Dark green hue, with tones of blue.\n * * **flagblue**: Royal blue tint\n * * **liquid**: Blue-inspired tint.\n * * **diamante**: Custom filter with a blue/turquoise tint.\n * * **radio**: Fallout-style radio effect.\n * * **twenties**: Slight-blue tinted historical effect.\n * * **rosetint**: Rose-tinted filter.\n * * **mauve**: Purple-infused filter.\n * * **bluechrome**: Blue monochrome effect.\n * * **vintage**: Vintage filter with a red tint.\n * * **perfume**: Increase the blue channel, with moderate increases in the Red and Green channels.\n * * **serenity**: Custom filter with an increase in the Blue channel's values.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `filter_name` - The filter's name. Choose from the selection above, eg: \"oceanic\"\n * # Example\n *\n * ```no_run\n * // For example, to add a filter called \"vintage\" to an image:\n * use photon_rs::filters::filter;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * filter(&mut img, \"vintage\");\n * ```\n * @param {PhotonImage} img\n * @param {string} filter_name\n */\nexport function filter(img, filter_name) {\n    _assertClass(img, PhotonImage);\n    const ptr0 = passStringToWasm0(filter_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.filter(img.__wbg_ptr, ptr0, len0);\n}\n\n/**\n * Apply a lofi effect to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::lofi;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lofi(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function lofi(img) {\n    _assertClass(img, PhotonImage);\n    wasm.lofi(img.__wbg_ptr);\n}\n\n/**\n * Apply a rose tint to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::pastel_pink;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * pastel_pink(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function pastel_pink(img) {\n    _assertClass(img, PhotonImage);\n    wasm.pastel_pink(img.__wbg_ptr);\n}\n\n/**\n * Apply a vintage, golden hue to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::golden;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * golden(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function golden(img) {\n    _assertClass(img, PhotonImage);\n    wasm.golden(img.__wbg_ptr);\n}\n\n/**\n * Increased contrast filter effect.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::cali;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * cali(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function cali(img) {\n    _assertClass(img, PhotonImage);\n    wasm.cali(img.__wbg_ptr);\n}\n\n/**\n * Greyscale effect with increased contrast.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::dramatic;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * dramatic(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function dramatic(img) {\n    _assertClass(img, PhotonImage);\n    wasm.dramatic(img.__wbg_ptr);\n}\n\n/**\n * Monochrome tint effect with increased contrast\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `rgb_color` - RGB color\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::monochrome_tint;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgb_color = Rgb::new(12, 12, 10);\n * monochrome_tint(&mut img, rgb_color);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} rgb_color\n */\nexport function monochrome_tint(img, rgb_color) {\n    _assertClass(img, PhotonImage);\n    _assertClass(rgb_color, Rgb);\n    var ptr0 = rgb_color.__destroy_into_raw();\n    wasm.monochrome_tint(img.__wbg_ptr, ptr0);\n}\n\n/**\n * Duotone effect with blue and purple tones.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_violette;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_violette(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_violette(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_violette(img.__wbg_ptr);\n}\n\n/**\n * Duotone effect with purple tones.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_horizon;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_horizon(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_horizon(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_horizon(img.__wbg_ptr);\n}\n\n/**\n * A duotone filter with a user-specified color and a gray color\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `rgb_color` - RGB color\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_tint;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgb_color = Rgb::new(12, 12, 10);\n * duotone_tint(&mut img, rgb_color);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} rgb_color\n */\nexport function duotone_tint(img, rgb_color) {\n    _assertClass(img, PhotonImage);\n    _assertClass(rgb_color, Rgb);\n    var ptr0 = rgb_color.__destroy_into_raw();\n    wasm.duotone_tint(img.__wbg_ptr, ptr0);\n}\n\n/**\n * Duotone effect with a lilac hue\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_lilac;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_lilac(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_lilac(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_lilac(img.__wbg_ptr);\n}\n\n/**\n * A duotone ochre tint effect\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_ochre;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_ochre(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_ochre(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_ochre(img.__wbg_ptr);\n}\n\n/**\n * Apply a red hue, with increased contrast and brightness.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::firenze;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * firenze(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function firenze(img) {\n    _assertClass(img, PhotonImage);\n    wasm.firenze(img.__wbg_ptr);\n}\n\n/**\n * Apply a greyscale effect with increased contrast.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::obsidian;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * obsidian(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function obsidian(img) {\n    _assertClass(img, PhotonImage);\n    wasm.obsidian(img.__wbg_ptr);\n}\n\n/**\n * Crop an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to crop an image at (0, 0) to (500, 800)\n * use photon_rs::native::{open_image};\n * use photon_rs::transform::crop;\n * use photon_rs::PhotonImage;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let cropped_img: PhotonImage = crop(&img, 0_u32, 0_u32, 500_u32, 800_u32);\n * // Write the contents of this image in JPG format.\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {PhotonImage}\n */\nexport function crop(photon_image, x1, y1, x2, y2) {\n    _assertClass(photon_image, PhotonImage);\n    const ret = wasm.crop(photon_image.__wbg_ptr, x1, y1, x2, y2);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * @param {HTMLCanvasElement} source_canvas\n * @param {number} width\n * @param {number} height\n * @param {number} left\n * @param {number} top\n * @returns {HTMLCanvasElement}\n */\nexport function crop_img_browser(source_canvas, width, height, left, top) {\n    const ret = wasm.crop_img_browser(source_canvas, width, height, left, top);\n    return ret;\n}\n\n/**\n * Flip an image horizontally.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to flip an image horizontally:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::fliph;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * fliph(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function fliph(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.fliph(photon_image.__wbg_ptr);\n}\n\n/**\n * Flip an image vertically.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to flip an image vertically:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::flipv;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * flipv(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function flipv(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.flipv(photon_image.__wbg_ptr);\n}\n\n/**\n * Resize an image on the web.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `width` - New width.\n * * `height` - New height.\n * * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n * @param {PhotonImage} photon_img\n * @param {number} width\n * @param {number} height\n * @param {SamplingFilter} sampling_filter\n * @returns {HTMLCanvasElement}\n */\nexport function resize_img_browser(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.resize_img_browser(photon_img.__wbg_ptr, width, height, sampling_filter);\n    return ret;\n}\n\n/**\n * Resize an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `width` - New width.\n * * `height` - New height.\n * * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n * @param {PhotonImage} photon_img\n * @param {number} width\n * @param {number} height\n * @param {SamplingFilter} sampling_filter\n * @returns {PhotonImage}\n */\nexport function resize(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.resize(photon_img.__wbg_ptr, width, height, sampling_filter);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Resize image using seam carver.\n * Resize only if new dimensions are smaller, than original image.\n * # NOTE: This is still experimental feature, and pretty slow.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `width` - New width.\n * * `height` - New height.\n *\n * # Example\n *\n * ```no_run\n * // For example, resize image using seam carver:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::seam_carve;\n * use photon_rs::PhotonImage;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let result: PhotonImage = seam_carve(&img, 100_u32, 100_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} width\n * @param {number} height\n * @returns {PhotonImage}\n */\nexport function seam_carve(img, width, height) {\n    _assertClass(img, PhotonImage);\n    const ret = wasm.seam_carve(img.__wbg_ptr, width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Shear the image along the X axis.\n * A sheared PhotonImage is returned.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `shear` - Amount to shear.\n *\n * # Example\n *\n * ```no_run\n * // For example, to shear an image by 0.5:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::shearx;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let sheared_img = shearx(&img, 0.5);\n * ```\n * @param {PhotonImage} photon_img\n * @param {number} shear\n * @returns {PhotonImage}\n */\nexport function shearx(photon_img, shear) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.shearx(photon_img.__wbg_ptr, shear);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Shear the image along the Y axis.\n * A sheared PhotonImage is returned.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `shear` - Amount to shear.\n *\n * # Example\n *\n * ```no_run\n * // For example, to shear an image by 0.5:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::sheary;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let sheared_img = sheary(&img, 0.5);\n * ```\n * @param {PhotonImage} photon_img\n * @param {number} shear\n * @returns {PhotonImage}\n */\nexport function sheary(photon_img, shear) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.sheary(photon_img.__wbg_ptr, shear);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply uniform padding around the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels around a PhotonImage:\n * use photon_rs::transform::padding_uniform;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_uniform(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_uniform(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_uniform(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the left side of a PhotonImage:\n * use photon_rs::transform::padding_left;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_left(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_left(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_left(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the right side of a PhotonImage:\n * use photon_rs::transform::padding_right;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_right(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_right(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_right(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the top of a PhotonImage:\n * use photon_rs::transform::padding_top;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_top(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_top(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_top(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the bottom of a PhotonImage:\n * use photon_rs::transform::padding_bottom;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_bottom(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_bottom(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_bottom(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Rotate the PhotonImage on an arbitrary angle\n * A rotated PhotonImage is returned.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `angle` - Rotation angle in degrees.\n *\n * # Example\n *\n * ```no_run\n * // For example, to rotate a PhotonImage by 30 degrees:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::rotate;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rotated_img = rotate(&img, 30.0);\n * ```\n * @param {PhotonImage} photon_img\n * @param {number} angle\n * @returns {PhotonImage}\n */\nexport function rotate(photon_img, angle) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.rotate(photon_img.__wbg_ptr, angle);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Resample the PhotonImage.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `dst_width` - Target width.\n * * `dst_height` - Target height.\n *\n * # Example\n *\n * ```no_run\n * // For example, to resample a PhotonImage to 1920x1080 size:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::resample;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rotated_img = resample(&img, 1920, 1080);\n * ```\n * @param {PhotonImage} img\n * @param {number} dst_width\n * @param {number} dst_height\n * @returns {PhotonImage}\n */\nexport function resample(img, dst_width, dst_height) {\n    _assertClass(img, PhotonImage);\n    const ret = wasm.resample(img.__wbg_ptr, dst_width, dst_height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Adds an offset to the image by a certain number of pixels.\n *\n * This creates an RGB shift effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `channel_index`: The index of the channel to increment. 0 for red, 1 for green and 2 for blue.\n * * `offset` - The offset is added to the pixels in the image.\n * # Example\n *\n * ```no_run\n * // For example, to offset pixels by 30 pixels on the red channel:\n * use photon_rs::effects::offset;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset(&mut img, 0_usize, 30_u32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} channel_index\n * @param {number} offset\n */\nexport function offset(photon_image, channel_index, offset) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.offset(photon_image.__wbg_ptr, channel_index, offset);\n}\n\n/**\n * Adds an offset to the red channel by a certain number of pixels.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset` - The offset you want to move the red channel by.\n * # Example\n *\n * ```no_run\n * // For example, to add an offset to the red channel by 30 pixels.\n * use photon_rs::effects::offset_red;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset_red(&mut img, 30_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} offset_amt\n */\nexport function offset_red(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_red(img.__wbg_ptr, offset_amt);\n}\n\n/**\n * Adds an offset to the green channel by a certain number of pixels.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset` - The offset you want to move the green channel by.\n * # Example\n *\n * ```no_run\n * // For example, to add an offset to the green channel by 30 pixels.\n * use photon_rs::effects::offset_green;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset_green(&mut img, 30_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} offset_amt\n */\nexport function offset_green(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_green(img.__wbg_ptr, offset_amt);\n}\n\n/**\n * Adds an offset to the blue channel by a certain number of pixels.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset_amt` - The offset you want to move the blue channel by.\n * # Example\n * // For example, to add an offset to the green channel by 40 pixels.\n *\n * ```no_run\n * use photon_rs::effects::offset_blue;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset_blue(&mut img, 40_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} offset_amt\n */\nexport function offset_blue(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_blue(img.__wbg_ptr, offset_amt);\n}\n\n/**\n * Adds multiple offsets to the image by a certain number of pixels (on two channels).\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset` - The offset is added to the pixels in the image.\n * # Example\n *\n * ```no_run\n * // For example, to add a 30-pixel offset to both the red and blue channels:\n * use photon_rs::effects::multiple_offsets;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * multiple_offsets(&mut img, 30_u32, 0_usize, 2_usize);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} offset\n * @param {number} channel_index\n * @param {number} channel_index2\n */\nexport function multiple_offsets(photon_image, offset, channel_index, channel_index2) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.multiple_offsets(photon_image.__wbg_ptr, offset, channel_index, channel_index2);\n}\n\n/**\n * Halftoning effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example:\n * use photon_rs::effects::halftone;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * halftone(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function halftone(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.halftone(photon_image.__wbg_ptr);\n}\n\n/**\n * Reduces an image to the primary colours.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to add a primary colour effect to an image of type `DynamicImage`:\n * use photon_rs::effects::primary;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * primary(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function primary(img) {\n    _assertClass(img, PhotonImage);\n    wasm.primary(img.__wbg_ptr);\n}\n\n/**\n * Colorizes the green channels of the image.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to colorize an image of type `PhotonImage`:\n * use photon_rs::effects::colorize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * colorize(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function colorize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.colorize(photon_image.__wbg_ptr);\n}\n\n/**\n * Applies a solarizing effect to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to colorize an image of type `PhotonImage`:\n * use photon_rs::effects::solarize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * solarize(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function solarize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.solarize(photon_image.__wbg_ptr);\n}\n\n/**\n * Applies a solarizing effect to an image and returns the resulting PhotonImage.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to solarize \"retimg\" an image of type `PhotonImage`:\n * use photon_rs::effects::solarize_retimg;\n * use photon_rs::native::open_image;\n * use photon_rs::PhotonImage;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let result: PhotonImage = solarize_retimg(&img);\n * ```\n * @param {PhotonImage} photon_image\n * @returns {PhotonImage}\n */\nexport function solarize_retimg(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    const ret = wasm.solarize_retimg(photon_image.__wbg_ptr);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Adjust the brightness of an image by a factor.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `brightness` - A u8 to add or subtract to the brightness. To increase\n * the brightness, pass a positive number (up to 255). To decrease the brightness,\n * pass a negative number instead.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::adjust_brightness;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * adjust_brightness(&mut img, 10_i16);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} brightness\n */\nexport function adjust_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.adjust_brightness(photon_image.__wbg_ptr, brightness);\n}\n\n/**\n * Increase the brightness of an image by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `brightness` - A u8 to add to the brightness.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::inc_brightness;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * inc_brightness(&mut img, 10_u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} brightness\n */\nexport function inc_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.inc_brightness(photon_image.__wbg_ptr, brightness);\n}\n\n/**\n * Decrease the brightness of an image by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `brightness` - A u8 to subtract from the brightness. It should be a positive number,\n * and this value will then be subtracted from the brightness.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::dec_brightness;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * dec_brightness(&mut img, 10_u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} brightness\n */\nexport function dec_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.dec_brightness(photon_image.__wbg_ptr, brightness);\n}\n\n/**\n * Adjust the contrast of an image by a factor.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `contrast` - An f32 factor used to adjust contrast. Between [-255.0, 255.0]. The algorithm will\n * clamp results if passed factor is out of range.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::adjust_contrast;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * adjust_contrast(&mut img, 30_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} contrast\n */\nexport function adjust_contrast(photon_image, contrast) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.adjust_contrast(photon_image.__wbg_ptr, contrast);\n}\n\n/**\n * Tint an image by adding an offset to averaged RGB channel values.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `r_offset` - The amount the R channel should be incremented by.\n * * `g_offset` - The amount the G channel should be incremented by.\n * * `b_offset` - The amount the B channel should be incremented by.\n * # Example\n *\n * ```no_run\n * // For example, to tint an image of type `PhotonImage`:\n * use photon_rs::effects::tint;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * tint(&mut img, 10_u32, 20_u32, 15_u32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} r_offset\n * @param {number} g_offset\n * @param {number} b_offset\n */\nexport function tint(photon_image, r_offset, g_offset, b_offset) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.tint(photon_image.__wbg_ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n * Horizontal strips. Divide an image into a series of equal-height strips, for an artistic effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The number of strips\n * # Example\n *\n * ```no_run\n * // For example, to draw horizontal strips on a `PhotonImage`:\n * use photon_rs::effects::horizontal_strips;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * horizontal_strips(&mut img, 8u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n */\nexport function horizontal_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.horizontal_strips(photon_image.__wbg_ptr, num_strips);\n}\n\n/**\n * Horizontal strips. Divide an image into a series of equal-width strips, for an artistic effect. Sepcify a color as well.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The numbder of strips\n * * `color` - Color of strips.\n * # Example\n *\n * ```no_run\n * // For example, to draw blue horizontal strips on a `PhotonImage`:\n * use photon_rs::effects::color_horizontal_strips;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let color = Rgb::new(255u8, 0u8, 0u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * color_horizontal_strips(&mut img, 8u8, color);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n * @param {Rgb} color\n */\nexport function color_horizontal_strips(photon_image, num_strips, color) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(color, Rgb);\n    var ptr0 = color.__destroy_into_raw();\n    wasm.color_horizontal_strips(photon_image.__wbg_ptr, num_strips, ptr0);\n}\n\n/**\n * Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The numbder of strips\n * # Example\n *\n * ```no_run\n * // For example, to draw vertical strips on a `PhotonImage`:\n * use photon_rs::effects::vertical_strips;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * vertical_strips(&mut img, 8u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n */\nexport function vertical_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.vertical_strips(photon_image.__wbg_ptr, num_strips);\n}\n\n/**\n * Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect. Sepcify a color as well.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The numbder of strips\n * * `color` - Color of strips.\n * # Example\n *\n * ```no_run\n * // For example, to draw red vertical strips on a `PhotonImage`:\n * use photon_rs::effects::color_vertical_strips;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let color = Rgb::new(255u8, 0u8, 0u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * color_vertical_strips(&mut img, 8u8, color);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n * @param {Rgb} color\n */\nexport function color_vertical_strips(photon_image, num_strips, color) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(color, Rgb);\n    var ptr0 = color.__destroy_into_raw();\n    wasm.color_vertical_strips(photon_image.__wbg_ptr, num_strips, ptr0);\n}\n\n/**\n * Turn an image into an oil painting\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `radius` - Radius of each paint particle\n * * `intesnity` - How artsy an Image should be\n * # Example\n *\n * ```no_run\n * // For example, to oil an image of type `PhotonImage`:\n * use photon_rs::effects::oil;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * oil(&mut img, 4i32, 55.0);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} radius\n * @param {number} intensity\n */\nexport function oil(photon_image, radius, intensity) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.oil(photon_image.__wbg_ptr, radius, intensity);\n}\n\n/**\n * Turn an image into an frosted glass see through\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into frosted glass see through:\n * use photon_rs::effects::frosted_glass;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * frosted_glass(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function frosted_glass(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.frosted_glass(photon_image.__wbg_ptr);\n}\n\n/**\n * Pixelize an image.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `pixel_size` - Targeted pixel size of generated image.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a pixelized image with 50 pixels blocks:\n * use photon_rs::effects::pixelize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * pixelize(&mut img, 50);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} pixel_size\n */\nexport function pixelize(photon_image, pixel_size) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.pixelize(photon_image.__wbg_ptr, pixel_size);\n}\n\n/**\n * Normalizes an image by remapping its range of pixels values. Only RGB\n * channels are processed and each channel is stretched to \\[0, 255\\] range\n * independently. This process is also known as contrast stretching.\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a normalized image:\n * use photon_rs::effects::normalize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * normalize(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function normalize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.normalize(photon_image.__wbg_ptr);\n}\n\n/**\n * Applies Floyd-Steinberg dithering to an image.\n * Only RGB channels are processed, alpha remains unchanged.\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `depth` - bits per channel. Clamped between 1 and 8.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a dithered image:\n * use photon_rs::effects::dither;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let depth = 1;\n * dither(&mut img, depth);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} depth\n */\nexport function dither(photon_image, depth) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.dither(photon_image.__wbg_ptr, depth);\n}\n\n/**\n * @param {PhotonImage} photon_image\n * @param {Rgb} color_a\n * @param {Rgb} color_b\n */\nexport function duotone(photon_image, color_a, color_b) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(color_a, Rgb);\n    var ptr0 = color_a.__destroy_into_raw();\n    _assertClass(color_b, Rgb);\n    var ptr1 = color_b.__destroy_into_raw();\n    wasm.duotone(photon_image.__wbg_ptr, ptr0, ptr1);\n}\n\n/**\n * @enum {1 | 2 | 3 | 4 | 5}\n */\nexport const SamplingFilter = Object.freeze({\n    Nearest: 1, \"1\": \"Nearest\",\n    Triangle: 2, \"2\": \"Triangle\",\n    CatmullRom: 3, \"3\": \"CatmullRom\",\n    Gaussian: 4, \"4\": \"Gaussian\",\n    Lanczos3: 5, \"5\": \"Lanczos3\",\n});\n\nconst PhotonImageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_photonimage_free(ptr >>> 0, 1));\n/**\n * Provides the image's height, width, and contains the image's raw pixels.\n * For use when communicating between JS and WASM, and also natively.\n */\nexport class PhotonImage {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PhotonImage.prototype);\n        obj.__wbg_ptr = ptr;\n        PhotonImageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PhotonImageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_photonimage_free(ptr, 0);\n    }\n    /**\n     * Create a new PhotonImage from a Vec of u8s, which represent raw pixels.\n     * @param {Uint8Array} raw_pixels\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(raw_pixels, width, height) {\n        const ptr0 = passArray8ToWasm0(raw_pixels, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.photonimage_new(ptr0, len0, width, height);\n        this.__wbg_ptr = ret >>> 0;\n        PhotonImageFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a new PhotonImage from a base64 string.\n     * @param {string} base64\n     * @returns {PhotonImage}\n     */\n    static new_from_base64(base64) {\n        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.base64_to_image(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Create a new PhotonImage from a byteslice.\n     * @param {Uint8Array} vec\n     * @returns {PhotonImage}\n     */\n    static new_from_byteslice(vec) {\n        const ptr0 = passArray8ToWasm0(vec, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.photonimage_new_from_byteslice(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Create a new PhotonImage from a Blob/File.\n     * @param {Blob} blob\n     * @returns {PhotonImage}\n     */\n    static new_from_blob(blob) {\n        const ret = wasm.photonimage_new_from_blob(blob);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Create a new PhotonImage from a HTMLImageElement\n     * @param {HTMLImageElement} image\n     * @returns {PhotonImage}\n     */\n    static new_from_image(image) {\n        const ret = wasm.photonimage_new_from_image(image);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Get the width of the PhotonImage.\n     * @returns {number}\n     */\n    get_width() {\n        const ret = wasm.photonimage_get_width(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get the PhotonImage's pixels as a Vec of u8s.\n     * @returns {Uint8Array}\n     */\n    get_raw_pixels() {\n        const ret = wasm.photonimage_get_raw_pixels(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Get the height of the PhotonImage.\n     * @returns {number}\n     */\n    get_height() {\n        const ret = wasm.photonimage_get_height(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Convert the PhotonImage to base64.\n     * @returns {string}\n     */\n    get_base64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.photonimage_get_base64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Convert the PhotonImage to raw bytes. Returns PNG.\n     * @returns {Uint8Array}\n     */\n    get_bytes() {\n        const ret = wasm.photonimage_get_bytes(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Convert the PhotonImage to raw bytes. Returns a JPEG.\n     * @param {number} quality\n     * @returns {Uint8Array}\n     */\n    get_bytes_jpeg(quality) {\n        const ret = wasm.photonimage_get_bytes_jpeg(this.__wbg_ptr, quality);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Convert the PhotonImage to raw bytes. Returns a WEBP.\n     * @returns {Uint8Array}\n     */\n    get_bytes_webp() {\n        const ret = wasm.photonimage_get_bytes_webp(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Convert the PhotonImage's raw pixels to JS-compatible ImageData.\n     * @returns {ImageData}\n     */\n    get_image_data() {\n        const ret = wasm.photonimage_get_image_data(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Convert ImageData to raw pixels, and update the PhotonImage's raw pixels to this.\n     * @param {ImageData} img_data\n     */\n    set_imgdata(img_data) {\n        wasm.photonimage_set_imgdata(this.__wbg_ptr, img_data);\n    }\n    /**\n     * Calculates estimated filesize and returns number of bytes\n     * @returns {bigint}\n     */\n    get_estimated_filesize() {\n        const ret = wasm.photonimage_get_estimated_filesize(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n}\n\nconst RgbFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rgb_free(ptr >>> 0, 1));\n/**\n * RGB color type.\n */\nexport class Rgb {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RgbFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rgb_free(ptr, 0);\n    }\n    /**\n     * Create a new RGB struct.\n     * @param {number} r\n     * @param {number} g\n     * @param {number} b\n     */\n    constructor(r, g, b) {\n        const ret = wasm.rgb_new(r, g, b);\n        this.__wbg_ptr = ret >>> 0;\n        RgbFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Set the Red value.\n     * @param {number} r\n     */\n    set_red(r) {\n        wasm.rgb_set_red(this.__wbg_ptr, r);\n    }\n    /**\n     * Get the Green value.\n     * @param {number} g\n     */\n    set_green(g) {\n        wasm.rgb_set_green(this.__wbg_ptr, g);\n    }\n    /**\n     * Set the Blue value.\n     * @param {number} b\n     */\n    set_blue(b) {\n        wasm.rgb_set_blue(this.__wbg_ptr, b);\n    }\n    /**\n     * Get the Red value.\n     * @returns {number}\n     */\n    get_red() {\n        const ret = wasm.rgb_get_red(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Green value.\n     * @returns {number}\n     */\n    get_green() {\n        const ret = wasm.rgb_get_green(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Blue value.\n     * @returns {number}\n     */\n    get_blue() {\n        const ret = wasm.rgb_get_blue(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RgbaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rgba_free(ptr >>> 0, 1));\n/**\n * RGBA color type.\n */\nexport class Rgba {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RgbaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rgba_free(ptr, 0);\n    }\n    /**\n     * Create a new RGBA struct.\n     * @param {number} r\n     * @param {number} g\n     * @param {number} b\n     * @param {number} a\n     */\n    constructor(r, g, b, a) {\n        const ret = wasm.rgba_new(r, g, b, a);\n        this.__wbg_ptr = ret >>> 0;\n        RgbaFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Set the Red value.\n     * @param {number} r\n     */\n    set_red(r) {\n        wasm.rgb_set_red(this.__wbg_ptr, r);\n    }\n    /**\n     * Get the Green value.\n     * @param {number} g\n     */\n    set_green(g) {\n        wasm.rgb_set_green(this.__wbg_ptr, g);\n    }\n    /**\n     * Set the Blue value.\n     * @param {number} b\n     */\n    set_blue(b) {\n        wasm.rgb_set_blue(this.__wbg_ptr, b);\n    }\n    /**\n     * Set the alpha value.\n     * @param {number} a\n     */\n    set_alpha(a) {\n        wasm.rgba_set_alpha(this.__wbg_ptr, a);\n    }\n    /**\n     * Get the Red value.\n     * @returns {number}\n     */\n    get_red() {\n        const ret = wasm.rgb_get_red(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Green value.\n     * @returns {number}\n     */\n    get_green() {\n        const ret = wasm.rgb_get_green(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Blue value.\n     * @returns {number}\n     */\n    get_blue() {\n        const ret = wasm.rgb_get_blue(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the alpha value for this color.\n     * @returns {number}\n     */\n    get_alpha() {\n        const ret = wasm.rgba_get_alpha(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_appendChild_8204974b7328bf98 = function() { return handleError(function (arg0, arg1) {\n        const ret = arg0.appendChild(arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_body_942ea927546a04ba = function(arg0) {\n        const ret = arg0.body;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = arg0.buffer;\n        return ret;\n    };\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\n        const ret = arg0.call(arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_createElement_8c9931a732ee2fea = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = arg0.createElement(getStringFromWasm0(arg1, arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_data_d1ed736c1e42b10e = function(arg0, arg1) {\n        const ret = arg1.data;\n        const ptr1 = passArray8ToWasm0(ret, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_document_d249400bd7bd996d = function(arg0) {\n        const ret = arg0.document;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_drawImage_03f7ae2a95a9605f = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        arg0.drawImage(arg1, arg2, arg3);\n    }, arguments) };\n    imports.wbg.__wbg_drawImage_2603e2b61e66d571 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {\n        arg0.drawImage(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n    }, arguments) };\n    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getContext_e9cf379449413580 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = arg0.getContext(getStringFromWasm0(arg1, arg2));\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    }, arguments) };\n    imports.wbg.__wbg_getImageData_c02374a30b126dab = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        const ret = arg0.getImageData(arg1, arg2, arg3, arg4);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_height_1d93eb7f5e355d97 = function(arg0) {\n        const ret = arg0.height;\n        return ret;\n    };\n    imports.wbg.__wbg_height_838cee19ba8597db = function(arg0) {\n        const ret = arg0.height;\n        return ret;\n    };\n    imports.wbg.__wbg_height_d3f39e12f0f62121 = function(arg0) {\n        const ret = arg0.height;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_CanvasRenderingContext2d_df82a4d3437bf1cc = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof CanvasRenderingContext2D;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_HtmlCanvasElement_2ea67072a7624ac5 = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof HTMLCanvasElement;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof Window;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {\n        const ret = new Error();\n        return ret;\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n        const ret = new Uint8Array(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_newwithu8clampedarrayandsh_7ea6ee082a25bc85 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = new ImageData(getClampedArrayU8FromWasm0(arg0, arg1), arg2 >>> 0, arg3 >>> 0);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_putImageData_4c5aa10f3b3e4924 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        arg0.putImageData(arg1, arg2, arg3);\n    }, arguments) };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n        arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_setheight_da683a33fa99843c = function(arg0, arg1) {\n        arg0.height = arg1 >>> 0;\n    };\n    imports.wbg.__wbg_settextContent_d29397f7b994d314 = function(arg0, arg1, arg2) {\n        arg0.textContent = arg1 === 0 ? undefined : getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_setwidth_c5fed9f5e7f0b406 = function(arg0, arg1) {\n        arg0.width = arg1 >>> 0;\n    };\n    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {\n        const ret = arg1.stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_width_4f334fc47ef03de1 = function(arg0) {\n        const ret = arg0.width;\n        return ret;\n    };\n    imports.wbg.__wbg_width_5dde457d606ba683 = function(arg0) {\n        const ret = arg0.width;\n        return ret;\n    };\n    imports.wbg.__wbg_width_b0c1d9f437a95799 = function(arg0) {\n        const ret = arg0.width;\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(arg1);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_2;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = arg0 === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    cachedUint8ClampedArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    //! Needed to remove these lines in order to make it work on next.js\n    // if (!(module instanceof WebAssembly.Module)) {\n    //     module = new WebAssembly.Module(module);\n    // }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    //! Needed to remove these lines in order to make it work on node.js\n    // if (typeof module_or_path === 'undefined') {\n    //     module_or_path = new URL('photon_rs_bg.wasm', import.meta.url);\n    // }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","import '@cf-wasm/internals/polyfills/image-data';\nimport initAsync, { type InitInput, type InitOutput, initSync, type SyncInitInput } from './lib/photon_rs';\n\n/** Initializes photon asynchronously */\nexport async function initPhoton(\n  input:\n    | {\n        module_or_path: InitInput | Promise<InitInput>;\n      }\n    | InitInput\n    | Promise<InitInput>,\n): Promise<InitOutput> {\n  if (initPhoton.initialized) {\n    throw new Error('(@cf-wasm/photon): Function already called. The `initPhoton()` function can be used only once.');\n  }\n  if (!input) {\n    throw new Error('(@cf-wasm/photon): Argument `input` is not valid.');\n  }\n  initPhoton.initialized = true;\n  initPhoton.promise = (async () => {\n    const output = await initAsync(await input);\n    initPhoton.ready = true;\n    return output;\n  })();\n  return initPhoton.promise;\n}\n\n/** Initializes photon synchronously */\ninitPhoton.sync = (input: { module: SyncInitInput } | SyncInitInput): InitOutput => {\n  if (initPhoton.initialized) {\n    throw new Error('(@cf-wasm/photon): Function already called. The `initPhoton()` function can be used only once.');\n  }\n  if (!input) {\n    throw new Error('(@cf-wasm/photon): Argument `input` is not valid.');\n  }\n  initPhoton.initialized = true;\n  const output = initSync(input);\n  initPhoton.promise = Promise.resolve(output);\n  initPhoton.ready = true;\n  return output;\n};\n\ninitPhoton.promise = null as Promise<InitOutput> | null;\n/** Indicates whether photon is initialized */\ninitPhoton.initialized = false;\n/** Indicates whether photon is ready */\ninitPhoton.ready = false;\n\n/** Ensures photon is ready */\ninitPhoton.ensure = async () => {\n  if (!initPhoton.promise) {\n    throw new Error('(@cf-wasm/photon): Function not called. Call `initPhoton()` function first.');\n  }\n  return initPhoton.promise;\n};\n\nexport {\n  add_noise_rand,\n  adjust_brightness,\n  adjust_contrast,\n  alter_blue_channel,\n  alter_channel,\n  alter_channels,\n  alter_green_channel,\n  alter_red_channel,\n  alter_two_channels,\n  apply_gradient,\n  b_grayscale,\n  base64_to_image,\n  base64_to_vec,\n  blend,\n  box_blur,\n  cali,\n  color_horizontal_strips,\n  color_vertical_strips,\n  colorize,\n  create_gradient,\n  crop,\n  crop_img_browser,\n  darken_hsl,\n  darken_hsluv,\n  darken_hsv,\n  darken_lch,\n  dec_brightness,\n  decompose_max,\n  decompose_min,\n  desaturate,\n  desaturate_hsl,\n  desaturate_hsluv,\n  desaturate_hsv,\n  desaturate_lch,\n  detect_45_deg_lines,\n  detect_135_deg_lines,\n  detect_horizontal_lines,\n  detect_vertical_lines,\n  dither,\n  dramatic,\n  draw_text,\n  draw_text_with_border,\n  duotone,\n  duotone_horizon,\n  duotone_lilac,\n  duotone_ochre,\n  duotone_tint,\n  duotone_violette,\n  edge_detection,\n  edge_one,\n  emboss,\n  filter,\n  firenze,\n  fliph,\n  flipv,\n  frosted_glass,\n  g_grayscale,\n  gamma_correction,\n  gaussian_blur,\n  get_image_data,\n  golden,\n  grayscale,\n  grayscale_human_corrected,\n  grayscale_shades,\n  halftone,\n  horizontal_strips,\n  hsl,\n  hsluv,\n  hsv,\n  hue_rotate_hsl,\n  hue_rotate_hsluv,\n  hue_rotate_hsv,\n  hue_rotate_lch,\n  type InitInput,\n  type InitOutput,\n  identity,\n  inc_brightness,\n  invert,\n  laplace,\n  lch,\n  lighten_hsl,\n  lighten_hsluv,\n  lighten_hsv,\n  lighten_lch,\n  lix,\n  lofi,\n  mix_with_colour,\n  monochrome,\n  monochrome_tint,\n  multiple_offsets,\n  neue,\n  noise_reduction,\n  normalize,\n  obsidian,\n  offset,\n  offset_blue,\n  offset_green,\n  offset_red,\n  oil,\n  open_image,\n  PhotonImage,\n  padding_bottom,\n  padding_left,\n  padding_right,\n  padding_top,\n  padding_uniform,\n  pastel_pink,\n  pink_noise,\n  pixelize,\n  prewitt_horizontal,\n  primary,\n  putImageData,\n  Rgb,\n  Rgba,\n  r_grayscale,\n  remove_blue_channel,\n  remove_channel,\n  remove_green_channel,\n  remove_red_channel,\n  resample,\n  resize,\n  resize_img_browser,\n  rotate,\n  run,\n  ryo,\n  SamplingFilter,\n  type SyncInitInput,\n  saturate_hsl,\n  saturate_hsluv,\n  saturate_hsv,\n  saturate_lch,\n  seam_carve,\n  selective_color_convert,\n  selective_desaturate,\n  selective_greyscale,\n  selective_hue_rotate,\n  selective_lighten,\n  selective_saturate,\n  sepia,\n  sharpen,\n  shearx,\n  sheary,\n  single_channel_grayscale,\n  sobel_global,\n  sobel_horizontal,\n  sobel_vertical,\n  solarize,\n  solarize_retimg,\n  swap_channels,\n  threshold,\n  tint,\n  to_image_data,\n  to_raw_pixels,\n  vertical_strips,\n  watermark,\n} from './lib/photon_rs';\n","import photonWasmModule from './lib/photon_rs_bg.wasm';\nimport { initPhoton } from './photon';\n\ninitPhoton.sync({ module: photonWasmModule });\n\nexport { photonWasmModule };\nexport * from './photon';\n"],"mappings":"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","names":["PerformanceMark","clear","count","countReset","createTask","debug","dir","dirxml","error","group","groupCollapsed","groupEnd","info","log","profile","profileEnd","table","time","timeEnd","timeLog","timeStamp","trace","warn","hrtime","dir","env","count","cwd","hrtime","assert","getColorSpaceFromImageSettings","ImageData","ptr","offset","debug","table","offset","scale"]}